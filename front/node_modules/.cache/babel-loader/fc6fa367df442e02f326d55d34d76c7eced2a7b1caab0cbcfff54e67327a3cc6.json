{"ast":null,"code":"import { Mutex } from \"async-mutex\";\nimport { NewLine } from \"../types\";\nexport const ENGINE_DEPTH = 10;\nconst META = {\n  engine: null\n};\nexport function getEngine() {\n  if (META.engine) {\n    return META.engine;\n  }\n  META.engine = eval(\"stockfish\");\n  META.engine.onerror = event => {\n    console.log({\n      event\n    });\n  };\n  return META.engine;\n}\nconst mutex = new Mutex();\nexport async function engineEval(fen, nbLines) {\n  return new Promise((_resolve, reject) => {\n    console.log(\"getting muttex\");\n    mutex.acquire().then(function (release) {\n      const resolve = value => {\n        console.log(\"releasing muttex\", value);\n        release();\n        _resolve(value);\n      };\n      // console.debug(\"computing line\")\n      const engine = getEngine();\n      // set number of lines to eval\n      META.engine.postMessage(`setoption name MultiPV value ${nbLines}`);\n      engine.postMessage(`position fen ${fen}`);\n      engine.postMessage(`go depth ${ENGINE_DEPTH}`);\n      // console.log('-------------');\n\n      const lines = [];\n      engine.onmessage = event => {\n        let message = event.data;\n        console.log(\"got message\", message);\n        if (message.startsWith(`info depth ${ENGINE_DEPTH}`)) {\n          // console.log(message);\n          const regx = message.match(`.*score (?<type>cp|mate) (?<score>.*) (upperbound|nodes).* pv (?<moves>.*)`);\n\n          // console.debug(\"got line\")\n\n          if (regx && regx.groups !== undefined) {\n            var _regx$groups, _regx$groups2, _regx$groups3;\n            const line = NewLine(Number(regx === null || regx === void 0 ? void 0 : (_regx$groups = regx.groups) === null || _regx$groups === void 0 ? void 0 : _regx$groups.score), regx === null || regx === void 0 ? void 0 : (_regx$groups2 = regx.groups) === null || _regx$groups2 === void 0 ? void 0 : _regx$groups2.type, regx === null || regx === void 0 ? void 0 : (_regx$groups3 = regx.groups) === null || _regx$groups3 === void 0 ? void 0 : _regx$groups3.moves);\n            lines.push(line);\n            if (isNaN(line.rawScore)) {\n              console.log({\n                line,\n                regx\n              });\n            }\n            if (lines.length === nbLines) {\n              console.log(\"releasing because all lines\");\n              engine.postMessage(`stop`);\n              resolve(lines.sort((a, b) => {\n                // negative value if first < the second argument, zero if ===, and a positive value otherwise.\n                // I want to see the highest score for the line first. Mates are always higher\n\n                // TODO ------> Maybe it has to be evaluated depending on how's playing ???\n\n                if (a.scoreType === \"mate\" && b.scoreType !== \"mate\") {\n                  return a.rawScore * 1000;\n                }\n                if (a.scoreType !== \"mate\" && b.scoreType === \"mate\") {\n                  return b.rawScore * 1000;\n                }\n                if (a.rawScore < 0) {\n                  if (b.rawScore >= 0) {\n                    return 1;\n                  } else {\n                    if (a.rawScore < b.rawScore) {\n                      return 1;\n                    } else if (a.rawScore > b.rawScore) {\n                      return 0;\n                    }\n                  }\n                } else {\n                  if (a.rawScore < b.rawScore) {\n                    return -1;\n                  } else if (a.rawScore > b.rawScore) {\n                    return 1;\n                  }\n                }\n                return 0;\n              }));\n            }\n          }\n        }\n      };\n\n      // it can happen that there aren't enought lines to match the nbLines. \n      // This is a fallback until I find a better way to detect that the engine is done searching.\n      setTimeout(() => {\n        console.log(\"releasing because timeout\");\n        resolve(lines.sort((a, b) => a.rawScore - b.rawScore));\n      }, 1000);\n    });\n  });\n}","map":{"version":3,"names":["Mutex","NewLine","ENGINE_DEPTH","META","engine","getEngine","eval","onerror","event","console","log","mutex","engineEval","fen","nbLines","Promise","_resolve","reject","acquire","then","release","resolve","value","postMessage","lines","onmessage","message","data","startsWith","regx","match","groups","undefined","_regx$groups","_regx$groups2","_regx$groups3","line","Number","score","type","moves","push","isNaN","rawScore","length","sort","a","b","scoreType","setTimeout"],"sources":["/Users/jcornevin/Dev/Perso/chess-analyser/src/components/right-menu/engine.ts"],"sourcesContent":["import { Mutex } from \"async-mutex\";\nimport { Line, NewLine } from \"../types\";\n\nexport const ENGINE_DEPTH = 10;\n\n\nconst META = {\n    engine: null\n}\n\nexport function getEngine() {\n    if (META.engine) {\n        return META.engine\n    }\n\n    META.engine = eval(\"stockfish\");\n\n    META.engine.onerror = (event: any) => {\n        console.log({event});\n    }\n    \n    return META.engine;\n}\n\nconst mutex = new Mutex();\n\nexport async function engineEval(fen: string, nbLines: number): Promise<Line[]> {\n    return new Promise((_resolve, reject) => {\n        console.log(\"getting muttex\")\n        mutex\n            .acquire()\n            .then(function(release) {\n                const resolve = (value: Line[] | PromiseLike<Line[]>) => {\n                    console.log(\"releasing muttex\", value)\n                    release();\n                    _resolve(value);\n                }\n                // console.debug(\"computing line\")\n                const engine = getEngine();\n                // set number of lines to eval\n                META.engine.postMessage(`setoption name MultiPV value ${nbLines}`)\n            \n                engine.postMessage(`position fen ${fen}`);\n                engine.postMessage(`go depth ${ENGINE_DEPTH}`);\n                // console.log('-------------');\n        \n                const lines: Line[] = [];\n                    \n                engine.onmessage = (event: { data: string }) => {\n                    let message = event.data;\n                    console.log(\"got message\", message);\n        \n                    if (message.startsWith(`info depth ${ENGINE_DEPTH}`)) {\n                        // console.log(message);\n                        const regx = message.match(`.*score (?<type>cp|mate) (?<score>.*) (upperbound|nodes).* pv (?<moves>.*)`);\n        \n                        // console.debug(\"got line\")\n                        \n                        if (regx && regx.groups !== undefined) {\n                            const line = NewLine(Number(regx?.groups?.score), regx?.groups?.type, regx?.groups?.moves);\n                            lines.push(line)\n        \n                            if (isNaN(line.rawScore)) {\n                                console.log({line, regx})\n                            }\n        \n                            if (lines.length === nbLines) {\n                                console.log(\"releasing because all lines\");\n                                engine.postMessage(`stop`);\n                                resolve(lines.sort((a, b) => {\n                                    // negative value if first < the second argument, zero if ===, and a positive value otherwise.\n                                    // I want to see the highest score for the line first. Mates are always higher\n        \n                                    // TODO ------> Maybe it has to be evaluated depending on how's playing ???\n        \n                                    if (a.scoreType === \"mate\" && b.scoreType !== \"mate\") {\n                                        return a.rawScore * 1000\n                                    }\n                                    if (a.scoreType !== \"mate\" && b.scoreType === \"mate\") {\n                                        return b.rawScore * 1000\n                                    }\n        \n                                    if (a.rawScore < 0) {\n                                        if (b.rawScore >= 0) {\n                                            return 1\n                                        } else {\n                                            if (a.rawScore < b.rawScore) {\n                                                return 1\n                                            } else if (a.rawScore > b.rawScore) {\n                                                return 0\n                                            }\n                                        }\n                                    } else {\n                                        if (a.rawScore < b.rawScore) {\n                                            return -1\n                                        } else if (a.rawScore > b.rawScore) {\n                                            return 1\n                                        }\n                                    }\n        \n        \n                                    return 0\n                                }));\n                            }\n                        }\n                    }\n                };\n        \n                // it can happen that there aren't enought lines to match the nbLines. \n                // This is a fallback until I find a better way to detect that the engine is done searching.\n                setTimeout(() => {\n                    console.log(\"releasing because timeout\");\n                    resolve(lines.sort((a, b) => (a.rawScore - b.rawScore)));\n                }, 1000)\n            });\n                \n    });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}