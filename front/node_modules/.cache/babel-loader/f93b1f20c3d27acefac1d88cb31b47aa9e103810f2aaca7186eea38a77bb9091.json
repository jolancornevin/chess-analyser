{"ast":null,"code":"import { engineEval } from './right-menu/engine';\nexport function NewLine(rawScore, scoreType, line) {\n  const isMate = scoreType === \"mate\";\n  const score = isMate ? rawScore : rawScore / 100;\n  return {\n    score: `${isMate ? \"M\" : \"\"}${score}`,\n    // in pawns\n    rawScore: rawScore,\n    // in centipawns\n    scoreType: scoreType,\n    line: line\n  };\n}\n_c = NewLine;\nexport function NewMove(value, moveNumber) {\n  return {\n    to: value.to,\n    fen: value.after,\n    number: moveNumber,\n    cmove: value\n  };\n}\n_c2 = NewMove;\nexport async function ComputeMoveScore(move) {\n  console.log(\"computing score\");\n  return new Promise(async (resolve, reject) => {\n    await engineEval(move.cmove.before, 3).then(async linesBefore => {\n      await engineEval(move.cmove.after, 3).then(linesAfter => {\n        let accuracy = 0;\n        let scoreDiff = 0;\n        console.log(`>>>> got scores for move ${move.to}`);\n        if (linesBefore.length > 0 && linesAfter.length > 0) {\n          const bestLineBefore = linesBefore[0];\n\n          // taking the last one because we want the best line for our opponent\n          const bestLineAfter = linesAfter[0];\n          const winPercentBefore = (2 / (1 + Math.exp(-0.00368208 * bestLineBefore.rawScore)) - 1) * 100;\n          const winPercentAfter = (2 / (1 + Math.exp(-0.00368208 * bestLineAfter.rawScore)) - 1) * 100;\n          if (winPercentAfter > winPercentBefore) {\n            accuracy = Math.round(103.1668100711649 * Math.exp(-0.04354415386753951 * (winPercentBefore - winPercentAfter)) - 3.166924740191411);\n          }\n\n          // Addition to take the perspective of the player playing, so we reverse the score.\n          // if we're white, the line after give a score for black, which will be negative if good for us.\n          scoreDiff = bestLineBefore.rawScore + bestLineAfter.rawScore;\n          console.log({\n            moveNumber: move.number,\n            linesBefore,\n            bestLineBefore,\n            winPercentBefore,\n            linesAfter,\n            bestLineAfter,\n            winPercentAfter,\n            accuracy,\n            scoreDiff\n          });\n          // if (scoreDiff < 0) {\n          // }\n        }\n\n        // TODO think more about the evals I want\n        // I need to compare the score AFTER the move VS the best line BEFORE the move (+all other metrics)\n        // If I want a graph, then I want the best score BEFORE each move.\n\n        const newMove = {\n          ...move\n        };\n        newMove.scoreDiff = `${scoreDiff}`; // (linesBefore.length > 0 ? linesBefore[0].score : \"-\")\n        newMove.accuracy = accuracy;\n        console.log(\"new scoreDiff is\", scoreDiff);\n        resolve(newMove);\n      });\n    });\n  });\n}\n_c3 = ComputeMoveScore;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"NewLine\");\n$RefreshReg$(_c2, \"NewMove\");\n$RefreshReg$(_c3, \"ComputeMoveScore\");","map":{"version":3,"names":["engineEval","NewLine","rawScore","scoreType","line","isMate","score","_c","NewMove","value","moveNumber","to","fen","after","number","cmove","_c2","ComputeMoveScore","move","console","log","Promise","resolve","reject","before","then","linesBefore","linesAfter","accuracy","scoreDiff","length","bestLineBefore","bestLineAfter","winPercentBefore","Math","exp","winPercentAfter","round","newMove","_c3","$RefreshReg$"],"sources":["/Users/jcornevin/Dev/Perso/chess-analyser/src/components/types.ts"],"sourcesContent":["\nimport { Move as cMove } from 'chess.js';\nimport { engineEval } from './right-menu/engine';\n\n\nexport interface Line {\n    line: string;\n\n    scoreType: string;\n\n    rawScore: number;\n    score: string;\n}\n\nexport function NewLine(rawScore, scoreType, line): Line {\n    const isMate = scoreType === \"mate\";\n    const score = isMate ? rawScore : rawScore / 100;\n    \n    return {\n        score: `${isMate ? \"M\" : \"\"}${score}`, // in pawns\n        rawScore: rawScore, // in centipawns\n        scoreType:scoreType,\n        line: line,\n    } \n}\n\n\nexport interface Move {\n    number: number;\n    to: string; // move (d4)\n    fen: string;\n    \n    cmove?: cMove;\n    scoreDiff?: string;\n    accuracy?: number;\n\n}\nexport function NewMove(value: cMove, moveNumber): Move {\n    return {\n        to: value.to,\n        fen: value.after,\n        number: moveNumber,\n        cmove: value,\n    }\n}\n\nexport async function ComputeMoveScore(move: Move): Promise<Move> {\n    console.log(\"computing score\")\n    \n    return new Promise(async (resolve, reject) => {\n        await engineEval(move.cmove.before, 3).then(async (linesBefore) => {\n            await engineEval(move.cmove.after, 3).then((linesAfter) => {\n                let accuracy = 0;\n                let scoreDiff = 0;\n\n                console.log(`>>>> got scores for move ${move.to}`);\n\n                if (linesBefore.length > 0 && linesAfter.length > 0) {\n                    const bestLineBefore = linesBefore[0];\n\n                    // taking the last one because we want the best line for our opponent\n                    const bestLineAfter = linesAfter[0];\n                    \n                    const winPercentBefore = (2 / (1 + Math.exp(-0.00368208 * bestLineBefore.rawScore)) - 1) * 100;\n                    const winPercentAfter = (2 / (1 + Math.exp(-0.00368208 * bestLineAfter.rawScore)) - 1) * 100;\n\n                    if (winPercentAfter > winPercentBefore) {\n                        accuracy = Math.round(103.1668100711649 * Math.exp(-0.04354415386753951 * (winPercentBefore - winPercentAfter)) -3.166924740191411);\n                    }\n\n                    // Addition to take the perspective of the player playing, so we reverse the score.\n                    // if we're white, the line after give a score for black, which will be negative if good for us.\n                    scoreDiff = bestLineBefore.rawScore + bestLineAfter.rawScore;\n                    \n                    console.log({ moveNumber: move.number, linesBefore, bestLineBefore, winPercentBefore, linesAfter, bestLineAfter, winPercentAfter, accuracy, scoreDiff });\n                    // if (scoreDiff < 0) {\n                    // }\n                }\n\n                // TODO think more about the evals I want\n                // I need to compare the score AFTER the move VS the best line BEFORE the move (+all other metrics)\n                // If I want a graph, then I want the best score BEFORE each move.\n\n                const newMove = { ...move };\n                \n                newMove.scoreDiff = `${scoreDiff}` // (linesBefore.length > 0 ? linesBefore[0].score : \"-\")\n                newMove.accuracy = accuracy\n\n                console.log(\"new scoreDiff is\", scoreDiff)\n                resolve(newMove);\n            });         \n        }); \n    });\n    \n}\n\n"],"mappings":"AAEA,SAASA,UAAU,QAAQ,qBAAqB;AAYhD,OAAO,SAASC,OAAOA,CAACC,QAAQ,EAAEC,SAAS,EAAEC,IAAI,EAAQ;EACrD,MAAMC,MAAM,GAAGF,SAAS,KAAK,MAAM;EACnC,MAAMG,KAAK,GAAGD,MAAM,GAAGH,QAAQ,GAAGA,QAAQ,GAAG,GAAG;EAEhD,OAAO;IACHI,KAAK,EAAE,GAAGD,MAAM,GAAG,GAAG,GAAG,EAAE,GAAGC,KAAK,EAAE;IAAE;IACvCJ,QAAQ,EAAEA,QAAQ;IAAE;IACpBC,SAAS,EAACA,SAAS;IACnBC,IAAI,EAAEA;EACV,CAAC;AACL;AAACG,EAAA,GAVeN,OAAO;AAuBvB,OAAO,SAASO,OAAOA,CAACC,KAAY,EAAEC,UAAU,EAAQ;EACpD,OAAO;IACHC,EAAE,EAAEF,KAAK,CAACE,EAAE;IACZC,GAAG,EAAEH,KAAK,CAACI,KAAK;IAChBC,MAAM,EAAEJ,UAAU;IAClBK,KAAK,EAAEN;EACX,CAAC;AACL;AAACO,GAAA,GAPeR,OAAO;AASvB,OAAO,eAAeS,gBAAgBA,CAACC,IAAU,EAAiB;EAC9DC,OAAO,CAACC,GAAG,CAAC,iBAAiB,CAAC;EAE9B,OAAO,IAAIC,OAAO,CAAC,OAAOC,OAAO,EAAEC,MAAM,KAAK;IAC1C,MAAMvB,UAAU,CAACkB,IAAI,CAACH,KAAK,CAACS,MAAM,EAAE,CAAC,CAAC,CAACC,IAAI,CAAC,MAAOC,WAAW,IAAK;MAC/D,MAAM1B,UAAU,CAACkB,IAAI,CAACH,KAAK,CAACF,KAAK,EAAE,CAAC,CAAC,CAACY,IAAI,CAAEE,UAAU,IAAK;QACvD,IAAIC,QAAQ,GAAG,CAAC;QAChB,IAAIC,SAAS,GAAG,CAAC;QAEjBV,OAAO,CAACC,GAAG,CAAC,4BAA4BF,IAAI,CAACP,EAAE,EAAE,CAAC;QAElD,IAAIe,WAAW,CAACI,MAAM,GAAG,CAAC,IAAIH,UAAU,CAACG,MAAM,GAAG,CAAC,EAAE;UACjD,MAAMC,cAAc,GAAGL,WAAW,CAAC,CAAC,CAAC;;UAErC;UACA,MAAMM,aAAa,GAAGL,UAAU,CAAC,CAAC,CAAC;UAEnC,MAAMM,gBAAgB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,UAAU,GAAGJ,cAAc,CAAC7B,QAAQ,CAAC,CAAC,GAAG,CAAC,IAAI,GAAG;UAC9F,MAAMkC,eAAe,GAAG,CAAC,CAAC,IAAI,CAAC,GAAGF,IAAI,CAACC,GAAG,CAAC,CAAC,UAAU,GAAGH,aAAa,CAAC9B,QAAQ,CAAC,CAAC,GAAG,CAAC,IAAI,GAAG;UAE5F,IAAIkC,eAAe,GAAGH,gBAAgB,EAAE;YACpCL,QAAQ,GAAGM,IAAI,CAACG,KAAK,CAAC,iBAAiB,GAAGH,IAAI,CAACC,GAAG,CAAC,CAAC,mBAAmB,IAAIF,gBAAgB,GAAGG,eAAe,CAAC,CAAC,GAAE,iBAAiB,CAAC;UACvI;;UAEA;UACA;UACAP,SAAS,GAAGE,cAAc,CAAC7B,QAAQ,GAAG8B,aAAa,CAAC9B,QAAQ;UAE5DiB,OAAO,CAACC,GAAG,CAAC;YAAEV,UAAU,EAAEQ,IAAI,CAACJ,MAAM;YAAEY,WAAW;YAAEK,cAAc;YAAEE,gBAAgB;YAAEN,UAAU;YAAEK,aAAa;YAAEI,eAAe;YAAER,QAAQ;YAAEC;UAAU,CAAC,CAAC;UACxJ;UACA;QACJ;;QAEA;QACA;QACA;;QAEA,MAAMS,OAAO,GAAG;UAAE,GAAGpB;QAAK,CAAC;QAE3BoB,OAAO,CAACT,SAAS,GAAG,GAAGA,SAAS,EAAE,EAAC;QACnCS,OAAO,CAACV,QAAQ,GAAGA,QAAQ;QAE3BT,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAES,SAAS,CAAC;QAC1CP,OAAO,CAACgB,OAAO,CAAC;MACpB,CAAC,CAAC;IACN,CAAC,CAAC;EACN,CAAC,CAAC;AAEN;AAACC,GAAA,GAhDqBtB,gBAAgB;AAAA,IAAAV,EAAA,EAAAS,GAAA,EAAAuB,GAAA;AAAAC,YAAA,CAAAjC,EAAA;AAAAiC,YAAA,CAAAxB,GAAA;AAAAwB,YAAA,CAAAD,GAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}