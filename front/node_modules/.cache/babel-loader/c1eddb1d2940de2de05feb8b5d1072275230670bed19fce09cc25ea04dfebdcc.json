{"ast":null,"code":"import { Mutex } from \"async-mutex\";\nimport { NewLine } from \"../types\";\nexport const ENGINE_DEPTH = 10;\nlet engine = null;\nexport async function getEngine() {\n  if (engine) {\n    return engine;\n  }\n\n  // engine = eval(\"stockfish\");\n  engine = window.stockfish;\n  engine.onerror = event => {\n    console.error({\n      event\n    });\n  };\n  await new Promise(resolve => {\n    engine.postMessage(`isready`);\n    engine.onmessage = event => {\n      let message = event.data;\n      if (message === \"readyok\") {\n        resolve(engine);\n      }\n    };\n  });\n  return engine;\n}\nconst mutex = new Mutex();\nexport async function engineEval(fen, nbLines) {\n  // console.log(\"asking muttex\")\n  const release = await mutex.acquire();\n  // console.log(\"got muttex\")\n\n  const lines = await _engineEval(fen, nbLines);\n  release();\n  // console.log(\"released muttex\")\n\n  return lines;\n}\nexport async function _engineEval(fen, nbLines) {\n  return new Promise(async (_resolve, reject) => {\n    const lines = [];\n    const resolve = value => {\n      console.log(\"resolving\", value);\n      clearTimeout(t);\n      _resolve(value);\n    };\n\n    // it can happen that there aren't enough lines to match the nbLines. \n    // This is a fallback until I find a better way to detect that the engine is done searching.\n    const t = setTimeout(() => {\n      resolve(lines.sort((a, b) => a.rawScore - b.rawScore));\n    }, 10000);\n    const engine = await getEngine();\n    // set number of lines to eval\n    engine.postMessage(`setoption name Threads value 6`);\n    engine.postMessage(`setoption name MultiPV value ${nbLines}`);\n    engine.postMessage(`setoption name UCI_ShowWDL value true`);\n    engine.postMessage(`ucinewgame`);\n    engine.postMessage(`position fen ${fen}`);\n    engine.postMessage(`go depth ${ENGINE_DEPTH}`);\n    // console.log('-------------');\n\n    engine.onmessage = event => {\n      let message = event.data;\n      console.log(message);\n      if (message.startsWith(`info depth ${ENGINE_DEPTH}`)) {\n        // console.log(message);\n        const regx = message.match(`.*score (?<type>cp|mate) (?<score>.*?) (wdl) (?<win>.*?) (?<draw>.*?) (?<lose>.*?) (upperbound|nodes).* pv (?<moves>.*)`);\n        if (regx && regx.groups !== undefined) {\n          var _regx$groups, _regx$groups2, _regx$groups3, _regx$groups4, _regx$groups5, _regx$groups6;\n          const line = NewLine(Number(regx === null || regx === void 0 ? void 0 : (_regx$groups = regx.groups) === null || _regx$groups === void 0 ? void 0 : _regx$groups.score), regx === null || regx === void 0 ? void 0 : (_regx$groups2 = regx.groups) === null || _regx$groups2 === void 0 ? void 0 : _regx$groups2.type, regx === null || regx === void 0 ? void 0 : (_regx$groups3 = regx.groups) === null || _regx$groups3 === void 0 ? void 0 : _regx$groups3.moves, Number(regx === null || regx === void 0 ? void 0 : (_regx$groups4 = regx.groups) === null || _regx$groups4 === void 0 ? void 0 : _regx$groups4.win), Number(regx === null || regx === void 0 ? void 0 : (_regx$groups5 = regx.groups) === null || _regx$groups5 === void 0 ? void 0 : _regx$groups5.draw), Number(regx === null || regx === void 0 ? void 0 : (_regx$groups6 = regx.groups) === null || _regx$groups6 === void 0 ? void 0 : _regx$groups6.lose));\n          lines.push(line);\n          if (isNaN(line.rawScore)) {\n            console.error('ERROR', {\n              line,\n              regx\n            });\n          }\n          if (lines.length === nbLines) {\n            // console.log(\"resolving because all lines\");\n            engine.postMessage(\"stop\");\n            // engine.postMessage(\"quit\");\n\n            lines.sort((a, b) => {\n              // negative value if first < the second argument, zero if ===, and a positive value otherwise.\n              // I want to see the highest score for the line first. Mates are always higher\n\n              // TODO ------> Maybe it has to be evaluated depending on how's playing ???\n\n              if (a.scoreType === \"mate\" && b.scoreType !== \"mate\") {\n                return a.rawScore * 1000;\n              }\n              if (a.scoreType !== \"mate\" && b.scoreType === \"mate\") {\n                return b.rawScore * 1000;\n              }\n              if (a.rawScore < 0) {\n                if (b.rawScore >= 0) {\n                  return 1;\n                } else {\n                  // we want the highest score first (sorting descending instead of ascending)\n                  if (a.rawScore < b.rawScore) {\n                    return 1;\n                  } else if (a.rawScore > b.rawScore) {\n                    return 0;\n                  }\n                }\n              } else {\n                // we want the highest score first (sorting descending instead of ascending)\n                if (a.rawScore < b.rawScore) {\n                  return 1;\n                } else if (a.rawScore > b.rawScore) {\n                  return -1;\n                } else {\n                  return 0;\n                }\n              }\n              return 0;\n            });\n            resolve(lines);\n          }\n        }\n      }\n    };\n  });\n}","map":{"version":3,"names":["Mutex","NewLine","ENGINE_DEPTH","engine","getEngine","window","stockfish","onerror","event","console","error","Promise","resolve","postMessage","onmessage","message","data","mutex","engineEval","fen","nbLines","release","acquire","lines","_engineEval","_resolve","reject","value","log","clearTimeout","t","setTimeout","sort","a","b","rawScore","startsWith","regx","match","groups","undefined","_regx$groups","_regx$groups2","_regx$groups3","_regx$groups4","_regx$groups5","_regx$groups6","line","Number","score","type","moves","win","draw","lose","push","isNaN","length","scoreType"],"sources":["/Users/jcornevin/Dev/Perso/chess-analyser/src/components/right-menu/engine.ts"],"sourcesContent":["import { Mutex } from \"async-mutex\";\nimport { Line, NewLine } from \"../types\";\n\nexport const ENGINE_DEPTH = 10;\n\ninterface Engine {\n    postMessage(string): void;\n    onmessage(string): void;\n    onerror(string): void;\n}\n\nlet engine = null;\n\ndeclare global {\n    interface Window { stockfish: any; }\n}\n\nexport async function getEngine(): Promise<Engine> {\n    if (engine) {\n        return engine\n    }\n    \n    // engine = eval(\"stockfish\");\n    engine = window.stockfish;\n\n    engine.onerror = (event: any) => {\n        console.error({event});\n    }\n\n    await new Promise((resolve) => {\n        engine.postMessage(`isready`);\n        engine.onmessage = (event: { data: string }) => {\n            let message = event.data;\n            if (message === \"readyok\") {\n                resolve(engine);\n            }\n        }\n    });\n\n    return engine;\n}\n\nconst mutex = new Mutex();\n\nexport async function engineEval(fen: string, nbLines: number): Promise<Line[]> {\n    // console.log(\"asking muttex\")\n    const release = await mutex.acquire();\n    // console.log(\"got muttex\")\n\n    const lines = await _engineEval(fen, nbLines);\n\n    release();\n    // console.log(\"released muttex\")\n\n    return lines;\n}\n\nexport async function _engineEval(fen: string, nbLines: number): Promise<Line[]> {\n    return new Promise(async (_resolve, reject) => {\n        const lines: Line[] = [];\n\n        const resolve = (value: Line[] | PromiseLike<Line[]>) => {\n            console.log(\"resolving\", value);\n            clearTimeout(t);\n            _resolve(value);\n        }\n\n        // it can happen that there aren't enough lines to match the nbLines. \n        // This is a fallback until I find a better way to detect that the engine is done searching.\n        const t = setTimeout(() => {\n            resolve(lines.sort((a, b) => (a.rawScore - b.rawScore)));\n        }, 10000);\n    \n        const engine = await getEngine();\n        // set number of lines to eval\n        engine.postMessage(`setoption name Threads value 6`)\n        \n        engine.postMessage(`setoption name MultiPV value ${nbLines}`)\n        engine.postMessage(`setoption name UCI_ShowWDL value true`)\n    \n        engine.postMessage(`ucinewgame`);\n        \n        engine.postMessage(`position fen ${fen}`);\n        engine.postMessage(`go depth ${ENGINE_DEPTH}`);\n        // console.log('-------------');\n\n        engine.onmessage = (event: { data: string }) => {\n            let message = event.data;\n            console.log(message);\n\n            if (message.startsWith(`info depth ${ENGINE_DEPTH}`)) {\n                // console.log(message);\n                const regx = message.match(`.*score (?<type>cp|mate) (?<score>.*?) (wdl) (?<win>.*?) (?<draw>.*?) (?<lose>.*?) (upperbound|nodes).* pv (?<moves>.*)`);\n                \n                if (regx && regx.groups !== undefined) {\n                    const line = NewLine(\n                        Number(regx?.groups?.score),\n                        regx?.groups?.type,\n                        regx?.groups?.moves,\n                        Number(regx?.groups?.win),\n                        Number(regx?.groups?.draw),\n                        Number(regx?.groups?.lose),\n                    );\n                    lines.push(line)\n\n                    if (isNaN(line.rawScore)) {\n                        console.error('ERROR', {line, regx})\n                    }\n\n                    if (lines.length === nbLines) {\n                        // console.log(\"resolving because all lines\");\n                        engine.postMessage(\"stop\");\n                        // engine.postMessage(\"quit\");\n                        \n                        lines.sort((a, b) => {\n                            // negative value if first < the second argument, zero if ===, and a positive value otherwise.\n                            // I want to see the highest score for the line first. Mates are always higher\n\n                            // TODO ------> Maybe it has to be evaluated depending on how's playing ???\n\n                            if (a.scoreType === \"mate\" && b.scoreType !== \"mate\") {\n                                return a.rawScore * 1000\n                            }\n                            if (a.scoreType !== \"mate\" && b.scoreType === \"mate\") {\n                                return b.rawScore * 1000\n                            }\n\n                            if (a.rawScore < 0) {\n                                if (b.rawScore >= 0) {\n                                    return 1\n                                } else {\n                                    // we want the highest score first (sorting descending instead of ascending)\n                                    if (a.rawScore < b.rawScore) {\n                                        return 1\n                                    } else if (a.rawScore > b.rawScore) {\n                                        return 0\n                                    }\n                                }\n                            } else {\n                                // we want the highest score first (sorting descending instead of ascending)\n                                if (a.rawScore < b.rawScore) {\n                                    return 1;\n                                } else if (a.rawScore > b.rawScore) {\n                                    return -1;\n                                } else {\n                                    return 0;\n                                }\n                            }\n\n\n                            return 0\n                        });\n\n                        resolve(lines);\n                    }\n                }\n            }\n        };\n    });\n}"],"mappings":"AAAA,SAASA,KAAK,QAAQ,aAAa;AACnC,SAAeC,OAAO,QAAQ,UAAU;AAExC,OAAO,MAAMC,YAAY,GAAG,EAAE;AAQ9B,IAAIC,MAAM,GAAG,IAAI;AAMjB,OAAO,eAAeC,SAASA,CAAA,EAAoB;EAC/C,IAAID,MAAM,EAAE;IACR,OAAOA,MAAM;EACjB;;EAEA;EACAA,MAAM,GAAGE,MAAM,CAACC,SAAS;EAEzBH,MAAM,CAACI,OAAO,GAAIC,KAAU,IAAK;IAC7BC,OAAO,CAACC,KAAK,CAAC;MAACF;IAAK,CAAC,CAAC;EAC1B,CAAC;EAED,MAAM,IAAIG,OAAO,CAAEC,OAAO,IAAK;IAC3BT,MAAM,CAACU,WAAW,CAAC,SAAS,CAAC;IAC7BV,MAAM,CAACW,SAAS,GAAIN,KAAuB,IAAK;MAC5C,IAAIO,OAAO,GAAGP,KAAK,CAACQ,IAAI;MACxB,IAAID,OAAO,KAAK,SAAS,EAAE;QACvBH,OAAO,CAACT,MAAM,CAAC;MACnB;IACJ,CAAC;EACL,CAAC,CAAC;EAEF,OAAOA,MAAM;AACjB;AAEA,MAAMc,KAAK,GAAG,IAAIjB,KAAK,CAAC,CAAC;AAEzB,OAAO,eAAekB,UAAUA,CAACC,GAAW,EAAEC,OAAe,EAAmB;EAC5E;EACA,MAAMC,OAAO,GAAG,MAAMJ,KAAK,CAACK,OAAO,CAAC,CAAC;EACrC;;EAEA,MAAMC,KAAK,GAAG,MAAMC,WAAW,CAACL,GAAG,EAAEC,OAAO,CAAC;EAE7CC,OAAO,CAAC,CAAC;EACT;;EAEA,OAAOE,KAAK;AAChB;AAEA,OAAO,eAAeC,WAAWA,CAACL,GAAW,EAAEC,OAAe,EAAmB;EAC7E,OAAO,IAAIT,OAAO,CAAC,OAAOc,QAAQ,EAAEC,MAAM,KAAK;IAC3C,MAAMH,KAAa,GAAG,EAAE;IAExB,MAAMX,OAAO,GAAIe,KAAmC,IAAK;MACrDlB,OAAO,CAACmB,GAAG,CAAC,WAAW,EAAED,KAAK,CAAC;MAC/BE,YAAY,CAACC,CAAC,CAAC;MACfL,QAAQ,CAACE,KAAK,CAAC;IACnB,CAAC;;IAED;IACA;IACA,MAAMG,CAAC,GAAGC,UAAU,CAAC,MAAM;MACvBnB,OAAO,CAACW,KAAK,CAACS,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAMD,CAAC,CAACE,QAAQ,GAAGD,CAAC,CAACC,QAAS,CAAC,CAAC;IAC5D,CAAC,EAAE,KAAK,CAAC;IAET,MAAMhC,MAAM,GAAG,MAAMC,SAAS,CAAC,CAAC;IAChC;IACAD,MAAM,CAACU,WAAW,CAAC,gCAAgC,CAAC;IAEpDV,MAAM,CAACU,WAAW,CAAC,gCAAgCO,OAAO,EAAE,CAAC;IAC7DjB,MAAM,CAACU,WAAW,CAAC,uCAAuC,CAAC;IAE3DV,MAAM,CAACU,WAAW,CAAC,YAAY,CAAC;IAEhCV,MAAM,CAACU,WAAW,CAAC,gBAAgBM,GAAG,EAAE,CAAC;IACzChB,MAAM,CAACU,WAAW,CAAC,YAAYX,YAAY,EAAE,CAAC;IAC9C;;IAEAC,MAAM,CAACW,SAAS,GAAIN,KAAuB,IAAK;MAC5C,IAAIO,OAAO,GAAGP,KAAK,CAACQ,IAAI;MACxBP,OAAO,CAACmB,GAAG,CAACb,OAAO,CAAC;MAEpB,IAAIA,OAAO,CAACqB,UAAU,CAAC,cAAclC,YAAY,EAAE,CAAC,EAAE;QAClD;QACA,MAAMmC,IAAI,GAAGtB,OAAO,CAACuB,KAAK,CAAC,yHAAyH,CAAC;QAErJ,IAAID,IAAI,IAAIA,IAAI,CAACE,MAAM,KAAKC,SAAS,EAAE;UAAA,IAAAC,YAAA,EAAAC,aAAA,EAAAC,aAAA,EAAAC,aAAA,EAAAC,aAAA,EAAAC,aAAA;UACnC,MAAMC,IAAI,GAAG9C,OAAO,CAChB+C,MAAM,CAACX,IAAI,aAAJA,IAAI,wBAAAI,YAAA,GAAJJ,IAAI,CAAEE,MAAM,cAAAE,YAAA,uBAAZA,YAAA,CAAcQ,KAAK,CAAC,EAC3BZ,IAAI,aAAJA,IAAI,wBAAAK,aAAA,GAAJL,IAAI,CAAEE,MAAM,cAAAG,aAAA,uBAAZA,aAAA,CAAcQ,IAAI,EAClBb,IAAI,aAAJA,IAAI,wBAAAM,aAAA,GAAJN,IAAI,CAAEE,MAAM,cAAAI,aAAA,uBAAZA,aAAA,CAAcQ,KAAK,EACnBH,MAAM,CAACX,IAAI,aAAJA,IAAI,wBAAAO,aAAA,GAAJP,IAAI,CAAEE,MAAM,cAAAK,aAAA,uBAAZA,aAAA,CAAcQ,GAAG,CAAC,EACzBJ,MAAM,CAACX,IAAI,aAAJA,IAAI,wBAAAQ,aAAA,GAAJR,IAAI,CAAEE,MAAM,cAAAM,aAAA,uBAAZA,aAAA,CAAcQ,IAAI,CAAC,EAC1BL,MAAM,CAACX,IAAI,aAAJA,IAAI,wBAAAS,aAAA,GAAJT,IAAI,CAAEE,MAAM,cAAAO,aAAA,uBAAZA,aAAA,CAAcQ,IAAI,CAC7B,CAAC;UACD/B,KAAK,CAACgC,IAAI,CAACR,IAAI,CAAC;UAEhB,IAAIS,KAAK,CAACT,IAAI,CAACZ,QAAQ,CAAC,EAAE;YACtB1B,OAAO,CAACC,KAAK,CAAC,OAAO,EAAE;cAACqC,IAAI;cAAEV;YAAI,CAAC,CAAC;UACxC;UAEA,IAAId,KAAK,CAACkC,MAAM,KAAKrC,OAAO,EAAE;YAC1B;YACAjB,MAAM,CAACU,WAAW,CAAC,MAAM,CAAC;YAC1B;;YAEAU,KAAK,CAACS,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;cACjB;cACA;;cAEA;;cAEA,IAAID,CAAC,CAACyB,SAAS,KAAK,MAAM,IAAIxB,CAAC,CAACwB,SAAS,KAAK,MAAM,EAAE;gBAClD,OAAOzB,CAAC,CAACE,QAAQ,GAAG,IAAI;cAC5B;cACA,IAAIF,CAAC,CAACyB,SAAS,KAAK,MAAM,IAAIxB,CAAC,CAACwB,SAAS,KAAK,MAAM,EAAE;gBAClD,OAAOxB,CAAC,CAACC,QAAQ,GAAG,IAAI;cAC5B;cAEA,IAAIF,CAAC,CAACE,QAAQ,GAAG,CAAC,EAAE;gBAChB,IAAID,CAAC,CAACC,QAAQ,IAAI,CAAC,EAAE;kBACjB,OAAO,CAAC;gBACZ,CAAC,MAAM;kBACH;kBACA,IAAIF,CAAC,CAACE,QAAQ,GAAGD,CAAC,CAACC,QAAQ,EAAE;oBACzB,OAAO,CAAC;kBACZ,CAAC,MAAM,IAAIF,CAAC,CAACE,QAAQ,GAAGD,CAAC,CAACC,QAAQ,EAAE;oBAChC,OAAO,CAAC;kBACZ;gBACJ;cACJ,CAAC,MAAM;gBACH;gBACA,IAAIF,CAAC,CAACE,QAAQ,GAAGD,CAAC,CAACC,QAAQ,EAAE;kBACzB,OAAO,CAAC;gBACZ,CAAC,MAAM,IAAIF,CAAC,CAACE,QAAQ,GAAGD,CAAC,CAACC,QAAQ,EAAE;kBAChC,OAAO,CAAC,CAAC;gBACb,CAAC,MAAM;kBACH,OAAO,CAAC;gBACZ;cACJ;cAGA,OAAO,CAAC;YACZ,CAAC,CAAC;YAEFvB,OAAO,CAACW,KAAK,CAAC;UAClB;QACJ;MACJ;IACJ,CAAC;EACL,CAAC,CAAC;AACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}