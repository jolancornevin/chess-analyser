{"ast":null,"code":"import { setCheck, setSelected } from './board.js';\nimport { read as fenRead } from './fen.js';\nexport function applyAnimation(state, config) {\n  if (config.animation) {\n    deepMerge(state.animation, config.animation);\n    // no need for such short animations\n    if ((state.animation.duration || 0) < 70) state.animation.enabled = false;\n  }\n}\nexport function configure(state, config) {\n  var _a, _b;\n  // don't merge destinations and autoShapes. Just override.\n  if ((_a = config.movable) === null || _a === void 0 ? void 0 : _a.dests) state.movable.dests = undefined;\n  if ((_b = config.drawable) === null || _b === void 0 ? void 0 : _b.autoShapes) state.drawable.autoShapes = [];\n  deepMerge(state, config);\n  // if a fen was provided, replace the pieces\n  if (config.fen) {\n    state.pieces = fenRead(config.fen);\n    state.drawable.shapes = [];\n  }\n  // apply config values that could be undefined yet meaningful\n  if ('check' in config) setCheck(state, config.check || false);\n  if ('lastMove' in config && !config.lastMove) state.lastMove = undefined;\n  // in case of ZH drop last move, there's a single square.\n  // if the previous last move had two squares,\n  // the merge algorithm will incorrectly keep the second square.\n  else if (config.lastMove) state.lastMove = config.lastMove;\n  // fix move/premove dests\n  if (state.selected) setSelected(state, state.selected);\n  applyAnimation(state, config);\n  if (!state.movable.rookCastle && state.movable.dests) {\n    const rank = state.movable.color === 'white' ? '1' : '8',\n      kingStartPos = 'e' + rank,\n      dests = state.movable.dests.get(kingStartPos),\n      king = state.pieces.get(kingStartPos);\n    if (!dests || !king || king.role !== 'king') return;\n    state.movable.dests.set(kingStartPos, dests.filter(d => !(d === 'a' + rank && dests.includes('c' + rank)) && !(d === 'h' + rank && dests.includes('g' + rank))));\n  }\n}\nfunction deepMerge(base, extend) {\n  for (const key in extend) {\n    if (Object.prototype.hasOwnProperty.call(extend, key)) {\n      if (Object.prototype.hasOwnProperty.call(base, key) && isPlainObject(base[key]) && isPlainObject(extend[key])) deepMerge(base[key], extend[key]);else base[key] = extend[key];\n    }\n  }\n}\nfunction isPlainObject(o) {\n  if (typeof o !== 'object' || o === null) return false;\n  const proto = Object.getPrototypeOf(o);\n  return proto === Object.prototype || proto === null;\n}","map":{"version":3,"names":["setCheck","setSelected","read","fenRead","applyAnimation","state","config","animation","deepMerge","duration","enabled","configure","_a","movable","dests","undefined","_b","drawable","autoShapes","fen","pieces","shapes","check","lastMove","selected","rookCastle","rank","color","kingStartPos","get","king","role","set","filter","d","includes","base","extend","key","Object","prototype","hasOwnProperty","call","isPlainObject","o","proto","getPrototypeOf"],"sources":["/Users/jcornevin/Dev/Perso/chess-analyser/node_modules/chessground/src/config.ts"],"sourcesContent":["import { HeadlessState } from './state.js';\nimport { setCheck, setSelected } from './board.js';\nimport { read as fenRead } from './fen.js';\nimport { DrawShape, DrawBrushes } from './draw.js';\nimport * as cg from './types.js';\n\nexport interface Config {\n  fen?: cg.FEN; // chess position in Forsyth notation\n  orientation?: cg.Color; // board orientation. white | black\n  turnColor?: cg.Color; // turn to play. white | black\n  check?: cg.Color | boolean; // true for current color, false to unset\n  lastMove?: cg.Key[]; // squares part of the last move [\"c3\", \"c4\"]\n  selected?: cg.Key; // square currently selected \"a1\"\n  coordinates?: boolean; // include coords attributes\n  autoCastle?: boolean; // immediately complete the castle by moving the rook after king move\n  viewOnly?: boolean; // don't bind events: the user will never be able to move pieces around\n  disableContextMenu?: boolean; // because who needs a context menu on a chessboard\n  addPieceZIndex?: boolean; // adds z-index values to pieces (for 3D)\n  addDimensionsCssVarsTo?: HTMLElement; // add --cg-width and --cg-height CSS vars containing the board's dimensions to this element\n  blockTouchScroll?: boolean; // block scrolling via touch dragging on the board, e.g. for coordinate training\n  // pieceKey: boolean; // add a data-key attribute to piece elements\n  highlight?: {\n    lastMove?: boolean; // add last-move class to squares\n    check?: boolean; // add check class to squares\n  };\n  animation?: {\n    enabled?: boolean;\n    duration?: number;\n  };\n  movable?: {\n    free?: boolean; // all moves are valid - board editor\n    color?: cg.Color | 'both'; // color that can move. white | black | both | undefined\n    dests?: cg.Dests; // valid moves. {\"a2\" [\"a3\" \"a4\"] \"b1\" [\"a3\" \"c3\"]}\n    showDests?: boolean; // whether to add the move-dest class on squares\n    events?: {\n      after?: (orig: cg.Key, dest: cg.Key, metadata: cg.MoveMetadata) => void; // called after the move has been played\n      afterNewPiece?: (role: cg.Role, key: cg.Key, metadata: cg.MoveMetadata) => void; // called after a new piece is dropped on the board\n    };\n    rookCastle?: boolean; // castle by moving the king to the rook\n  };\n  premovable?: {\n    enabled?: boolean; // allow premoves for color that can not move\n    showDests?: boolean; // whether to add the premove-dest class on squares\n    castle?: boolean; // whether to allow king castle premoves\n    dests?: cg.Key[]; // premove destinations for the current selection\n    events?: {\n      set?: (orig: cg.Key, dest: cg.Key, metadata?: cg.SetPremoveMetadata) => void; // called after the premove has been set\n      unset?: () => void; // called after the premove has been unset\n    };\n  };\n  predroppable?: {\n    enabled?: boolean; // allow predrops for color that can not move\n    events?: {\n      set?: (role: cg.Role, key: cg.Key) => void; // called after the predrop has been set\n      unset?: () => void; // called after the predrop has been unset\n    };\n  };\n  draggable?: {\n    enabled?: boolean; // allow moves & premoves to use drag'n drop\n    distance?: number; // minimum distance to initiate a drag; in pixels\n    autoDistance?: boolean; // lets chessground set distance to zero when user drags pieces\n    showGhost?: boolean; // show ghost of piece being dragged\n    deleteOnDropOff?: boolean; // delete a piece when it is dropped off the board\n  };\n  selectable?: {\n    // disable to enforce dragging over click-click move\n    enabled?: boolean;\n  };\n  events?: {\n    change?: () => void; // called after the situation changes on the board\n    // called after a piece has been moved.\n    // capturedPiece is undefined or like {color: 'white'; 'role': 'queen'}\n    move?: (orig: cg.Key, dest: cg.Key, capturedPiece?: cg.Piece) => void;\n    dropNewPiece?: (piece: cg.Piece, key: cg.Key) => void;\n    select?: (key: cg.Key) => void; // called when a square is selected\n    insert?: (elements: cg.Elements) => void; // when the board DOM has been (re)inserted\n  };\n  drawable?: {\n    enabled?: boolean; // can draw\n    visible?: boolean; // can view\n    defaultSnapToValidMove?: boolean;\n    // false to keep the drawing if a movable piece is clicked.\n    // Clicking an empty square or immovable piece will clear the drawing regardless.\n    eraseOnClick?: boolean;\n    shapes?: DrawShape[];\n    autoShapes?: DrawShape[];\n    brushes?: DrawBrushes;\n    onChange?: (shapes: DrawShape[]) => void; // called after drawable shapes change\n  };\n}\n\nexport function applyAnimation(state: HeadlessState, config: Config): void {\n  if (config.animation) {\n    deepMerge(state.animation, config.animation);\n    // no need for such short animations\n    if ((state.animation.duration || 0) < 70) state.animation.enabled = false;\n  }\n}\n\nexport function configure(state: HeadlessState, config: Config): void {\n  // don't merge destinations and autoShapes. Just override.\n  if (config.movable?.dests) state.movable.dests = undefined;\n  if (config.drawable?.autoShapes) state.drawable.autoShapes = [];\n\n  deepMerge(state, config);\n\n  // if a fen was provided, replace the pieces\n  if (config.fen) {\n    state.pieces = fenRead(config.fen);\n    state.drawable.shapes = [];\n  }\n\n  // apply config values that could be undefined yet meaningful\n  if ('check' in config) setCheck(state, config.check || false);\n  if ('lastMove' in config && !config.lastMove) state.lastMove = undefined;\n  // in case of ZH drop last move, there's a single square.\n  // if the previous last move had two squares,\n  // the merge algorithm will incorrectly keep the second square.\n  else if (config.lastMove) state.lastMove = config.lastMove;\n\n  // fix move/premove dests\n  if (state.selected) setSelected(state, state.selected);\n\n  applyAnimation(state, config);\n\n  if (!state.movable.rookCastle && state.movable.dests) {\n    const rank = state.movable.color === 'white' ? '1' : '8',\n      kingStartPos = ('e' + rank) as cg.Key,\n      dests = state.movable.dests.get(kingStartPos),\n      king = state.pieces.get(kingStartPos);\n    if (!dests || !king || king.role !== 'king') return;\n    state.movable.dests.set(\n      kingStartPos,\n      dests.filter(\n        d =>\n          !(d === 'a' + rank && dests.includes(('c' + rank) as cg.Key)) &&\n          !(d === 'h' + rank && dests.includes(('g' + rank) as cg.Key))\n      )\n    );\n  }\n}\n\nfunction deepMerge(base: any, extend: any): void {\n  for (const key in extend) {\n    if (Object.prototype.hasOwnProperty.call(extend, key)) {\n      if (Object.prototype.hasOwnProperty.call(base, key) && isPlainObject(base[key]) && isPlainObject(extend[key]))\n        deepMerge(base[key], extend[key]);\n      else base[key] = extend[key];\n    }\n  }\n}\n\nfunction isPlainObject(o: unknown): boolean {\n  if (typeof o !== 'object' || o === null) return false;\n  const proto = Object.getPrototypeOf(o);\n  return proto === Object.prototype || proto === null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}