{"ast":null,"code":"import { engineEval } from './right-menu/engine';\nexport function NewLine(rawScore, scoreType, line) {\n  const isMate = scoreType === \"mate\";\n  const score = isMate ? rawScore : rawScore / 100;\n  return {\n    score: `${isMate ? \"M\" : \"\"}${score}`,\n    // in pawns\n    rawScore: rawScore,\n    // in centipawns\n    scoreType: scoreType,\n    line: line\n  };\n}\n_c = NewLine;\nexport function NewMove(value, moveNumber) {\n  return {\n    to: value.to,\n    fen: value.after,\n    number: moveNumber,\n    cmove: value\n  };\n}\n_c2 = NewMove;\nexport async function ComputeMoveScore(move) {\n  await engineEval(move.cmove.before, 3).then(async linesBefore => {\n    await engineEval(move.cmove.after, 3).then(linesAfter => {\n      let accuracy = 0;\n      let evaluation = 0;\n      if (linesBefore.length > 0 && linesAfter.length > 0) {\n        const bestLineBefore = linesBefore[0];\n        const bestLineAfter = linesAfter[0];\n        const winPercentBefore = 2 / (1 + Math.exp(-0.00368208 * bestLineBefore.rawScore)) - 1;\n        const winPercentAfter = 2 / (1 + Math.exp(-0.00368208 * bestLineAfter.rawScore)) - 1;\n        if (winPercentAfter > winPercentBefore) {\n          accuracy = 100;\n        } else {\n          accuracy = Math.round(103.1668100711649 * Math.exp(-0.04354415386753951 * (winPercentBefore - winPercentAfter)) - 3.166924740191411);\n        }\n        console.log({\n          x: move.number,\n          linesBefore,\n          bestLineBefore,\n          winPercentBefore,\n          linesAfter,\n          bestLineAfter,\n          winPercentAfter,\n          accuracy\n        });\n        evaluation = bestLineBefore.rawScore - bestLineAfter.rawScore;\n        // if (evaluation < 0) {\n        // }\n      }\n\n      // TODO think more about the evals I want\n      // I need to compare the score AFTER the move VS the best line BEFORE the move (+all other metrics)\n      // If I want a graph, then I want the best score BEFORE each move. \n\n      move.eval = `${evaluation}`; // (linesBefore.length > 0 ? linesBefore[0].score : \"-\")\n      move.accuracy = accuracy;\n    });\n  });\n}\n_c3 = ComputeMoveScore;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"NewLine\");\n$RefreshReg$(_c2, \"NewMove\");\n$RefreshReg$(_c3, \"ComputeMoveScore\");","map":{"version":3,"names":["engineEval","NewLine","rawScore","scoreType","line","isMate","score","_c","NewMove","value","moveNumber","to","fen","after","number","cmove","_c2","ComputeMoveScore","move","before","then","linesBefore","linesAfter","accuracy","evaluation","length","bestLineBefore","bestLineAfter","winPercentBefore","Math","exp","winPercentAfter","round","console","log","x","eval","_c3","$RefreshReg$"],"sources":["/Users/jcornevin/Dev/Perso/chess-analyser/src/components/types.ts"],"sourcesContent":["\nimport { Move as cMove } from 'chess.js';\nimport { engineEval } from './right-menu/engine';\n\nexport function NewLine(rawScore, scoreType, line): Line {\n    const isMate = scoreType === \"mate\";\n    const score = isMate ? rawScore : rawScore / 100;\n    \n    return {\n        score: `${isMate ? \"M\" : \"\"}${score}`, // in pawns\n        rawScore: rawScore, // in centipawns\n        scoreType:scoreType,\n        line: line,\n    } \n}\nexport function NewMove(value: cMove, moveNumber): Move {\n    return {\n        to: value.to,\n        fen: value.after,\n        number: moveNumber,\n        cmove: value,\n    }\n}\n\nexport async function ComputeMoveScore(move: Move) {\n    await engineEval(move.cmove.before, 3).then(async (linesBefore) => {\n        await engineEval(move.cmove.after, 3).then((linesAfter) => {\n            let accuracy = 0;\n            let evaluation = 0;\n\n            if (linesBefore.length > 0 && linesAfter.length > 0) {\n                const bestLineBefore = linesBefore[0];\n                const bestLineAfter = linesAfter[0];\n                \n                const winPercentBefore = 2 / (1 + Math.exp(-0.00368208 * bestLineBefore.rawScore)) - 1;\n                const winPercentAfter = 2 / (1 + Math.exp(-0.00368208 * bestLineAfter.rawScore)) - 1;\n\n                if (winPercentAfter > winPercentBefore) {\n                    accuracy = 100\n                } else {\n                    accuracy = Math.round(103.1668100711649 * Math.exp(-0.04354415386753951 * (winPercentBefore - winPercentAfter)) -3.166924740191411);\n                }\n                console.log({x: move.number, linesBefore, bestLineBefore, winPercentBefore, linesAfter, bestLineAfter, winPercentAfter, accuracy})\n\n                evaluation = bestLineBefore.rawScore - bestLineAfter.rawScore;\n                // if (evaluation < 0) {\n                // }\n            }\n\n            // TODO think more about the evals I want\n            // I need to compare the score AFTER the move VS the best line BEFORE the move (+all other metrics)\n            // If I want a graph, then I want the best score BEFORE each move. \n            \n            move.eval = `${evaluation}` // (linesBefore.length > 0 ? linesBefore[0].score : \"-\")\n            move.accuracy = accuracy\n        });         \n    });\n    \n}\n\nexport interface Line {\n    line: string;\n\n    scoreType: string;\n\n    rawScore: number;\n    score: string;\n}\n\nexport interface Move {\n    number: number;\n    to: string; // move (d4)\n    fen: string;\n    \n    cmove?: cMove;\n    eval?: string;\n    accuracy?: number;\n\n}\n"],"mappings":"AAEA,SAASA,UAAU,QAAQ,qBAAqB;AAEhD,OAAO,SAASC,OAAOA,CAACC,QAAQ,EAAEC,SAAS,EAAEC,IAAI,EAAQ;EACrD,MAAMC,MAAM,GAAGF,SAAS,KAAK,MAAM;EACnC,MAAMG,KAAK,GAAGD,MAAM,GAAGH,QAAQ,GAAGA,QAAQ,GAAG,GAAG;EAEhD,OAAO;IACHI,KAAK,EAAE,GAAGD,MAAM,GAAG,GAAG,GAAG,EAAE,GAAGC,KAAK,EAAE;IAAE;IACvCJ,QAAQ,EAAEA,QAAQ;IAAE;IACpBC,SAAS,EAACA,SAAS;IACnBC,IAAI,EAAEA;EACV,CAAC;AACL;AAACG,EAAA,GAVeN,OAAO;AAWvB,OAAO,SAASO,OAAOA,CAACC,KAAY,EAAEC,UAAU,EAAQ;EACpD,OAAO;IACHC,EAAE,EAAEF,KAAK,CAACE,EAAE;IACZC,GAAG,EAAEH,KAAK,CAACI,KAAK;IAChBC,MAAM,EAAEJ,UAAU;IAClBK,KAAK,EAAEN;EACX,CAAC;AACL;AAACO,GAAA,GAPeR,OAAO;AASvB,OAAO,eAAeS,gBAAgBA,CAACC,IAAU,EAAE;EAC/C,MAAMlB,UAAU,CAACkB,IAAI,CAACH,KAAK,CAACI,MAAM,EAAE,CAAC,CAAC,CAACC,IAAI,CAAC,MAAOC,WAAW,IAAK;IAC/D,MAAMrB,UAAU,CAACkB,IAAI,CAACH,KAAK,CAACF,KAAK,EAAE,CAAC,CAAC,CAACO,IAAI,CAAEE,UAAU,IAAK;MACvD,IAAIC,QAAQ,GAAG,CAAC;MAChB,IAAIC,UAAU,GAAG,CAAC;MAElB,IAAIH,WAAW,CAACI,MAAM,GAAG,CAAC,IAAIH,UAAU,CAACG,MAAM,GAAG,CAAC,EAAE;QACjD,MAAMC,cAAc,GAAGL,WAAW,CAAC,CAAC,CAAC;QACrC,MAAMM,aAAa,GAAGL,UAAU,CAAC,CAAC,CAAC;QAEnC,MAAMM,gBAAgB,GAAG,CAAC,IAAI,CAAC,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,UAAU,GAAGJ,cAAc,CAACxB,QAAQ,CAAC,CAAC,GAAG,CAAC;QACtF,MAAM6B,eAAe,GAAG,CAAC,IAAI,CAAC,GAAGF,IAAI,CAACC,GAAG,CAAC,CAAC,UAAU,GAAGH,aAAa,CAACzB,QAAQ,CAAC,CAAC,GAAG,CAAC;QAEpF,IAAI6B,eAAe,GAAGH,gBAAgB,EAAE;UACpCL,QAAQ,GAAG,GAAG;QAClB,CAAC,MAAM;UACHA,QAAQ,GAAGM,IAAI,CAACG,KAAK,CAAC,iBAAiB,GAAGH,IAAI,CAACC,GAAG,CAAC,CAAC,mBAAmB,IAAIF,gBAAgB,GAAGG,eAAe,CAAC,CAAC,GAAE,iBAAiB,CAAC;QACvI;QACAE,OAAO,CAACC,GAAG,CAAC;UAACC,CAAC,EAAEjB,IAAI,CAACJ,MAAM;UAAEO,WAAW;UAAEK,cAAc;UAAEE,gBAAgB;UAAEN,UAAU;UAAEK,aAAa;UAAEI,eAAe;UAAER;QAAQ,CAAC,CAAC;QAElIC,UAAU,GAAGE,cAAc,CAACxB,QAAQ,GAAGyB,aAAa,CAACzB,QAAQ;QAC7D;QACA;MACJ;;MAEA;MACA;MACA;;MAEAgB,IAAI,CAACkB,IAAI,GAAG,GAAGZ,UAAU,EAAE,EAAC;MAC5BN,IAAI,CAACK,QAAQ,GAAGA,QAAQ;IAC5B,CAAC,CAAC;EACN,CAAC,CAAC;AAEN;AAACc,GAAA,GAlCqBpB,gBAAgB;AAAA,IAAAV,EAAA,EAAAS,GAAA,EAAAqB,GAAA;AAAAC,YAAA,CAAA/B,EAAA;AAAA+B,YAAA,CAAAtB,GAAA;AAAAsB,YAAA,CAAAD,GAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}