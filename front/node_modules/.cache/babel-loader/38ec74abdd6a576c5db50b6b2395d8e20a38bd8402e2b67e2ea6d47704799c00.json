{"ast":null,"code":"import * as board from './board.js';\nimport { write as fenWrite } from './fen.js';\nimport { configure, applyAnimation } from './config.js';\nimport { anim, render } from './anim.js';\nimport { cancel as dragCancel, dragNewPiece } from './drag.js';\nimport { explosion } from './explosion.js';\n// see API types and documentations in dts/api.d.ts\nexport function start(state, redrawAll) {\n  function toggleOrientation() {\n    board.toggleOrientation(state);\n    redrawAll();\n  }\n  return {\n    set(config) {\n      if (config.orientation && config.orientation !== state.orientation) toggleOrientation();\n      applyAnimation(state, config);\n      (config.fen ? anim : render)(state => configure(state, config), state);\n    },\n    state,\n    getFen: () => fenWrite(state.pieces),\n    toggleOrientation,\n    setPieces(pieces) {\n      anim(state => board.setPieces(state, pieces), state);\n    },\n    selectSquare(key, force) {\n      if (key) anim(state => board.selectSquare(state, key, force), state);else if (state.selected) {\n        board.unselect(state);\n        state.dom.redraw();\n      }\n    },\n    move(orig, dest) {\n      anim(state => board.baseMove(state, orig, dest), state);\n    },\n    newPiece(piece, key) {\n      anim(state => board.baseNewPiece(state, piece, key), state);\n    },\n    playPremove() {\n      if (state.premovable.current) {\n        if (anim(board.playPremove, state)) return true;\n        // if the premove couldn't be played, redraw to clear it up\n        state.dom.redraw();\n      }\n      return false;\n    },\n    playPredrop(validate) {\n      if (state.predroppable.current) {\n        const result = board.playPredrop(state, validate);\n        state.dom.redraw();\n        return result;\n      }\n      return false;\n    },\n    cancelPremove() {\n      render(board.unsetPremove, state);\n    },\n    cancelPredrop() {\n      render(board.unsetPredrop, state);\n    },\n    cancelMove() {\n      render(state => {\n        board.cancelMove(state);\n        dragCancel(state);\n      }, state);\n    },\n    stop() {\n      render(state => {\n        board.stop(state);\n        dragCancel(state);\n      }, state);\n    },\n    explode(keys) {\n      explosion(state, keys);\n    },\n    setAutoShapes(shapes) {\n      render(state => state.drawable.autoShapes = shapes, state);\n    },\n    setShapes(shapes) {\n      render(state => state.drawable.shapes = shapes, state);\n    },\n    getKeyAtDomPos(pos) {\n      return board.getKeyAtDomPos(pos, board.whitePov(state), state.dom.bounds());\n    },\n    redrawAll,\n    dragNewPiece(piece, event, force) {\n      dragNewPiece(state, piece, event, force);\n    },\n    destroy() {\n      board.stop(state);\n      state.dom.unbind && state.dom.unbind();\n      state.dom.destroyed = true;\n    }\n  };\n}","map":{"version":3,"names":["board","write","fenWrite","configure","applyAnimation","anim","render","cancel","dragCancel","dragNewPiece","explosion","start","state","redrawAll","toggleOrientation","set","config","orientation","fen","getFen","pieces","setPieces","selectSquare","key","force","selected","unselect","dom","redraw","move","orig","dest","baseMove","newPiece","piece","baseNewPiece","playPremove","premovable","current","playPredrop","validate","predroppable","result","cancelPremove","unsetPremove","cancelPredrop","unsetPredrop","cancelMove","stop","explode","keys","setAutoShapes","shapes","drawable","autoShapes","setShapes","getKeyAtDomPos","pos","whitePov","bounds","event","destroy","unbind","destroyed"],"sources":["/Users/jcornevin/Dev/Perso/chess-analyser/node_modules/chessground/src/api.ts"],"sourcesContent":["import { State } from './state.js';\nimport * as board from './board.js';\nimport { write as fenWrite } from './fen.js';\nimport { Config, configure, applyAnimation } from './config.js';\nimport { anim, render } from './anim.js';\nimport { cancel as dragCancel, dragNewPiece } from './drag.js';\nimport { DrawShape } from './draw.js';\nimport { explosion } from './explosion.js';\nimport * as cg from './types.js';\n\nexport interface Api {\n  // reconfigure the instance. Accepts all config options, except for viewOnly & drawable.visible.\n  // board will be animated accordingly, if animations are enabled.\n  set(config: Config): void;\n\n  // read chessground state; write at your own risks.\n  state: State;\n\n  // get the position as a FEN string (only contains pieces, no flags)\n  // e.g. rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR\n  getFen(): cg.FEN;\n\n  // change the view angle\n  toggleOrientation(): void;\n\n  // perform a move programmatically\n  move(orig: cg.Key, dest: cg.Key): void;\n\n  // add and/or remove arbitrary pieces on the board\n  setPieces(pieces: cg.PiecesDiff): void;\n\n  // click a square programmatically\n  selectSquare(key: cg.Key | null, force?: boolean): void;\n\n  // put a new piece on the board\n  newPiece(piece: cg.Piece, key: cg.Key): void;\n\n  // play the current premove, if any; returns true if premove was played\n  playPremove(): boolean;\n\n  // cancel the current premove, if any\n  cancelPremove(): void;\n\n  // play the current predrop, if any; returns true if premove was played\n  playPredrop(validate: (drop: cg.Drop) => boolean): boolean;\n\n  // cancel the current predrop, if any\n  cancelPredrop(): void;\n\n  // cancel the current move being made\n  cancelMove(): void;\n\n  // cancel current move and prevent further ones\n  stop(): void;\n\n  // make squares explode (atomic chess)\n  explode(keys: cg.Key[]): void;\n\n  // programmatically draw user shapes\n  setShapes(shapes: DrawShape[]): void;\n\n  // programmatically draw auto shapes\n  setAutoShapes(shapes: DrawShape[]): void;\n\n  // square name at this DOM position (like \"e4\")\n  getKeyAtDomPos(pos: cg.NumberPair): cg.Key | undefined;\n\n  // only useful when CSS changes the board width/height ratio (for 3D)\n  redrawAll: cg.Redraw;\n\n  // for crazyhouse and board editors\n  dragNewPiece(piece: cg.Piece, event: cg.MouchEvent, force?: boolean): void;\n\n  // unbinds all events\n  // (important for document-wide events like scroll and mousemove)\n  destroy: cg.Unbind;\n}\n\n// see API types and documentations in dts/api.d.ts\nexport function start(state: State, redrawAll: cg.Redraw): Api {\n  function toggleOrientation(): void {\n    board.toggleOrientation(state);\n    redrawAll();\n  }\n\n  return {\n    set(config): void {\n      if (config.orientation && config.orientation !== state.orientation) toggleOrientation();\n      applyAnimation(state, config);\n      (config.fen ? anim : render)(state => configure(state, config), state);\n    },\n\n    state,\n\n    getFen: () => fenWrite(state.pieces),\n\n    toggleOrientation,\n\n    setPieces(pieces): void {\n      anim(state => board.setPieces(state, pieces), state);\n    },\n\n    selectSquare(key, force): void {\n      if (key) anim(state => board.selectSquare(state, key, force), state);\n      else if (state.selected) {\n        board.unselect(state);\n        state.dom.redraw();\n      }\n    },\n\n    move(orig, dest): void {\n      anim(state => board.baseMove(state, orig, dest), state);\n    },\n\n    newPiece(piece, key): void {\n      anim(state => board.baseNewPiece(state, piece, key), state);\n    },\n\n    playPremove(): boolean {\n      if (state.premovable.current) {\n        if (anim(board.playPremove, state)) return true;\n        // if the premove couldn't be played, redraw to clear it up\n        state.dom.redraw();\n      }\n      return false;\n    },\n\n    playPredrop(validate): boolean {\n      if (state.predroppable.current) {\n        const result = board.playPredrop(state, validate);\n        state.dom.redraw();\n        return result;\n      }\n      return false;\n    },\n\n    cancelPremove(): void {\n      render(board.unsetPremove, state);\n    },\n\n    cancelPredrop(): void {\n      render(board.unsetPredrop, state);\n    },\n\n    cancelMove(): void {\n      render(state => {\n        board.cancelMove(state);\n        dragCancel(state);\n      }, state);\n    },\n\n    stop(): void {\n      render(state => {\n        board.stop(state);\n        dragCancel(state);\n      }, state);\n    },\n\n    explode(keys: cg.Key[]): void {\n      explosion(state, keys);\n    },\n\n    setAutoShapes(shapes: DrawShape[]): void {\n      render(state => (state.drawable.autoShapes = shapes), state);\n    },\n\n    setShapes(shapes: DrawShape[]): void {\n      render(state => (state.drawable.shapes = shapes), state);\n    },\n\n    getKeyAtDomPos(pos): cg.Key | undefined {\n      return board.getKeyAtDomPos(pos, board.whitePov(state), state.dom.bounds());\n    },\n\n    redrawAll,\n\n    dragNewPiece(piece, event, force): void {\n      dragNewPiece(state, piece, event, force);\n    },\n\n    destroy(): void {\n      board.stop(state);\n      state.dom.unbind && state.dom.unbind();\n      state.dom.destroyed = true;\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}