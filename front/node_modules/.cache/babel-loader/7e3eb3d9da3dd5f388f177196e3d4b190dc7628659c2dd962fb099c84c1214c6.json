{"ast":null,"code":"import { NewLine } from \"../types\";\nexport const ENGINE_DEPTH = 10;\nconst META = {\n  engine: null\n};\nexport function getEngine() {\n  if (META.engine) {\n    return META.engine;\n  }\n  META.engine = eval(\"stockfish\");\n  META.engine.onerror = event => {\n    console.log({\n      event\n    });\n  };\n  return META.engine;\n}\nexport async function searchFromFen(fen, nbLines) {\n  return new Promise((resolve, reject) => {\n    // console.debug(\"computing line\")\n    const engine = getEngine();\n    // set number of lines to eval\n    META.engine.postMessage(`setoption name MultiPV value ${nbLines}`);\n    engine.postMessage(`position fen ${fen}`);\n    engine.postMessage(`go depth ${ENGINE_DEPTH}`);\n    console.log('-------------');\n    const lines = [];\n    engine.onmessage = event => {\n      let message = event.data;\n      if (message.startsWith(`info depth ${ENGINE_DEPTH}`)) {\n        console.log(message);\n        const regx = message.match(`.*score (?<type>cp|mate) (?<score>.*) nodes.* pv (?<moves>.*)`);\n\n        // console.debug(\"got line\")\n\n        if (regx && regx.groups !== undefined) {\n          var _regx$groups, _regx$groups2, _regx$groups3;\n          lines.push(NewLine(Number(regx === null || regx === void 0 ? void 0 : (_regx$groups = regx.groups) === null || _regx$groups === void 0 ? void 0 : _regx$groups.score) || 0, (regx === null || regx === void 0 ? void 0 : (_regx$groups2 = regx.groups) === null || _regx$groups2 === void 0 ? void 0 : _regx$groups2.type) || \"\", (regx === null || regx === void 0 ? void 0 : (_regx$groups3 = regx.groups) === null || _regx$groups3 === void 0 ? void 0 : _regx$groups3.moves) || \"\"));\n          if (lines.length === nbLines) {\n            engine.postMessage(`stop`);\n            resolve(lines.sort((a, b) => {\n              // negative value if first < the second argument, zero if ===, and a positive value otherwise.\n              // I want to see the highest score for the line first. Mates are always higher\n\n              if (a.scoreType === \"mate\" && b.scoreType !== \"mate\") {\n                return a.rawScore * 1000;\n              }\n              if (a.scoreType !== \"mate\" && b.scoreType === \"mate\") {\n                return b.rawScore * 1000;\n              }\n              if (a.rawScore < 0) {\n                if (b.rawScore >= 0) {\n                  return 1;\n                } else {\n                  if (a.rawScore < b.rawScore) {\n                    return 1;\n                  } else if (a.rawScore > b.rawScore) {\n                    return 0;\n                  }\n                }\n              } else {\n                if (a.rawScore < b.rawScore) {\n                  return -1;\n                } else if (a.rawScore > b.rawScore) {\n                  return 1;\n                }\n              }\n              return 0;\n            }));\n          }\n        }\n      }\n    };\n\n    // it can happen that there aren't enought lines to match the nbLines. \n    // This is a fallback until I find a better way to detect that the engine is done searching.\n    setTimeout(() => {\n      resolve(lines.sort((a, b) => a.rawScore - b.rawScore));\n    }, 1000);\n  });\n}","map":{"version":3,"names":["NewLine","ENGINE_DEPTH","META","engine","getEngine","eval","onerror","event","console","log","searchFromFen","fen","nbLines","Promise","resolve","reject","postMessage","lines","onmessage","message","data","startsWith","regx","match","groups","undefined","_regx$groups","_regx$groups2","_regx$groups3","push","Number","score","type","moves","length","sort","a","b","scoreType","rawScore","setTimeout"],"sources":["/Users/jcornevin/Dev/Perso/chess-analyser/src/components/right-menu/engine.ts"],"sourcesContent":["import { Line, NewLine } from \"../types\";\n\nexport const ENGINE_DEPTH = 10;\n\n\nconst META = {\n    engine: null\n}\n\nexport function getEngine() {\n    if (META.engine) {\n        return META.engine\n    }\n\n    META.engine = eval(\"stockfish\");\n\n    META.engine.onerror = (event: any) => {\n        console.log({event});\n    }\n    \n    return META.engine;\n}\n\nexport async function searchFromFen(fen: string, nbLines: number): Promise<Line[]> {\n\n    return new Promise((resolve, reject) => {\n        // console.debug(\"computing line\")\n        const engine = getEngine();\n        // set number of lines to eval\n        META.engine.postMessage(`setoption name MultiPV value ${nbLines}`)\n    \n        engine.postMessage(`position fen ${fen}`);\n        engine.postMessage(`go depth ${ENGINE_DEPTH}`);\n        console.log('-------------');\n\n        const lines: Line[] = [];\n            \n        engine.onmessage = (event: { data: string }) => {\n            let message = event.data;\n\n            if (message.startsWith(`info depth ${ENGINE_DEPTH}`)) {\n                console.log(message);\n                const regx = message.match(`.*score (?<type>cp|mate) (?<score>.*) nodes.* pv (?<moves>.*)`);\n\n                // console.debug(\"got line\")\n                \n                if (regx && regx.groups !== undefined) {\n                    lines.push(NewLine(Number(regx?.groups?.score) || 0, regx?.groups?.type || \"\", regx?.groups?.moves || \"\",))\n\n                    if (lines.length === nbLines) {\n                        engine.postMessage(`stop`);\n                        resolve(lines.sort((a, b) => {\n                            // negative value if first < the second argument, zero if ===, and a positive value otherwise.\n                            // I want to see the highest score for the line first. Mates are always higher\n\n                            if (a.scoreType === \"mate\" && b.scoreType !== \"mate\") {\n                                return a.rawScore * 1000\n                            }\n                            if (a.scoreType !== \"mate\" && b.scoreType === \"mate\") {\n                                return b.rawScore * 1000\n                            }\n\n                            if (a.rawScore < 0) {\n                                if (b.rawScore >= 0) {\n                                    return 1\n                                } else {\n                                    if (a.rawScore < b.rawScore) {\n                                        return 1\n                                    } else if (a.rawScore > b.rawScore) {\n                                        return 0\n                                    }\n                                }\n                            } else {\n                                if (a.rawScore < b.rawScore) {\n                                    return -1\n                                } else if (a.rawScore > b.rawScore) {\n                                    return 1\n                                }\n\n                            }\n\n\n                            return 0\n                        }));\n                    }\n                }\n            }\n        };\n\n        // it can happen that there aren't enought lines to match the nbLines. \n        // This is a fallback until I find a better way to detect that the engine is done searching.\n        setTimeout(() => {resolve(lines.sort((a, b) => (a.rawScore - b.rawScore)));}, 1000)\n    });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}