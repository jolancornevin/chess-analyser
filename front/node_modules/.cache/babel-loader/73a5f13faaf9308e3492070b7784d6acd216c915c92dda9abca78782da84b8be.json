{"ast":null,"code":"import { engineEval } from './right-menu/engine';\nexport function NewLine(rawScore, scoreType, line) {\n  const isMate = scoreType === \"mate\";\n  const score = isMate ? rawScore : rawScore / 100;\n  return {\n    score: `${isMate ? \"M\" : \"\"}${score}`,\n    // in pawns\n    rawScore: rawScore,\n    // in centipawns\n    scoreType: scoreType,\n    line: line\n  };\n}\n_c = NewLine;\nexport function NewMove(id, value, moveNumber) {\n  return {\n    id: id,\n    to: value.to,\n    fen: value.after,\n    number: moveNumber,\n    cmove: value\n  };\n}\n_c2 = NewMove;\nlet cache = {};\nexport function resetEngineCache() {\n  cache = {};\n}\nexport async function ComputeMoveScore(move) {\n  if (!cache[move.id]) {\n    cache[move.id] = new Promise(async (resolve, reject) => {\n      console.log(\"computing for real for \", move.id);\n      await engineEval(move.cmove.before, 3).then(async linesBefore => {\n        await engineEval(move.cmove.after, 3).then(linesAfter => {\n          let accuracy = 0;\n          let scoreDiff = 0;\n          console.log(`>>>> got scores for move ${move.to} with ${move.cmove.before} and ${move.cmove.after}`);\n          if (linesBefore.length > 0 && linesAfter.length > 0) {\n            const bestLineBefore = linesBefore[0];\n\n            // taking the last one because we want the best line for our opponent\n            const bestLineAfter = linesAfter[0];\n            // Addition to take the perspective of the player playing, so we reverse the score.\n            // if we're white, the line after give a score for black, which will be negative if good for us.\n            bestLineAfter.rawScore *= -1;\n            const winPercentBefore = (2 / (1 + Math.exp(-0.00368208 * bestLineBefore.rawScore)) - 1) * 100;\n            const winPercentAfter = (2 / (1 + Math.exp(-0.00368208 * bestLineAfter.rawScore)) - 1) * 100;\n            if (winPercentAfter > winPercentBefore) {\n              accuracy = 100;\n            } else {\n              accuracy = Math.round(103.1668100711649 * Math.exp(-0.04354415386753951 * (winPercentBefore - winPercentAfter)) - 3.166924740191411);\n            }\n            scoreDiff = bestLineBefore.rawScore - bestLineAfter.rawScore;\n            let wasOnlyMore =\n            // engine found more than one line\n            linesBefore.length >= 2\n            // the diff between the first line and seconde is high\n            && linesBefore[0].rawScore > linesBefore[1].rawScore + 200\n            // and we played the move\n            && linesBefore[0].line.startsWith(move.cmove.lan);\n            console.log({\n              moveNumber: move.number,\n              move,\n              linesBefore,\n              bestLineBefore,\n              winPercentBefore,\n              linesAfter,\n              bestLineAfter,\n              winPercentAfter,\n              accuracy,\n              scoreDiff\n            });\n            const newMove = {\n              ...move,\n              scoreDiff: scoreDiff,\n              // (linesBefore.length > 0 ? linesBefore[0].score : \"-\")\n              accuracy: accuracy,\n              scoreBefore: bestLineBefore.rawScore,\n              scoreAfter: bestLineAfter.rawScore,\n              wasOnlyMore: wasOnlyMore\n            };\n            resolve(newMove);\n          } else {\n            resolve(move);\n          }\n        });\n      });\n    });\n  }\n  return cache[move.id];\n}\n_c3 = ComputeMoveScore;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"NewLine\");\n$RefreshReg$(_c2, \"NewMove\");\n$RefreshReg$(_c3, \"ComputeMoveScore\");","map":{"version":3,"names":["engineEval","NewLine","rawScore","scoreType","line","isMate","score","_c","NewMove","id","value","moveNumber","to","fen","after","number","cmove","_c2","cache","resetEngineCache","ComputeMoveScore","move","Promise","resolve","reject","console","log","before","then","linesBefore","linesAfter","accuracy","scoreDiff","length","bestLineBefore","bestLineAfter","winPercentBefore","Math","exp","winPercentAfter","round","wasOnlyMore","startsWith","lan","newMove","scoreBefore","scoreAfter","_c3","$RefreshReg$"],"sources":["/Users/jcornevin/Dev/Perso/chess-analyser/src/components/types.ts"],"sourcesContent":["\nimport { Move as cMove } from 'chess.js';\nimport { engineEval } from './right-menu/engine';\n\n\nexport interface Line {\n    line: string;\n\n    scoreType: string;\n\n    rawScore: number;\n    score: string;\n}\n\nexport function NewLine(rawScore, scoreType, line): Line {\n    const isMate = scoreType === \"mate\";\n    const score = isMate ? rawScore : rawScore / 100;\n    \n    return {\n        score: `${isMate ? \"M\" : \"\"}${score}`, // in pawns\n        rawScore: rawScore, // in centipawns\n        scoreType:scoreType,\n        line: line,\n    } \n}\n\nexport interface Move {\n    id: number;\n\n    number: number;\n    to: string; // move (d4)\n    fen: string;\n    \n    cmove?: cMove;\n    scoreDiff?: number;\n    accuracy?: number;\n\n    scoreBefore?: number;\n    scoreAfter?: number;\n\n    wasOnlyMore?: boolean;\n}\nexport function NewMove(id: number, value: cMove, moveNumber: number): Move {\n    return {\n        id: id,\n\n        to: value.to,\n        fen: value.after,\n        number: moveNumber,\n        cmove: value,\n    }\n}\n\nlet cache = {};\n\nexport function resetEngineCache() {\n    cache = {};\n}\n\nexport async function ComputeMoveScore(move: Move): Promise<Move> {   \n    if (!cache[move.id]) {\n        cache[move.id] = new Promise(async (resolve, reject) => {\n            console.log(\"computing for real for \", move.id)\n            await engineEval(move.cmove.before, 3).then(async (linesBefore) => {\n                await engineEval(move.cmove.after, 3).then((linesAfter) => {\n                    let accuracy = 0;\n                    let scoreDiff = 0;\n    \n                    console.log(`>>>> got scores for move ${move.to} with ${move.cmove.before} and ${move.cmove.after}`);\n    \n                    if (linesBefore.length > 0 && linesAfter.length > 0) {\n                        const bestLineBefore = linesBefore[0];\n    \n                        // taking the last one because we want the best line for our opponent\n                        const bestLineAfter = linesAfter[0];\n                        // Addition to take the perspective of the player playing, so we reverse the score.\n                        // if we're white, the line after give a score for black, which will be negative if good for us.\n                        bestLineAfter.rawScore *= -1;\n                        \n                        const winPercentBefore = (2 / (1 + Math.exp(-0.00368208 * bestLineBefore.rawScore)) - 1) * 100;\n                        const winPercentAfter = (2 / (1 + Math.exp(-0.00368208 * bestLineAfter.rawScore)) - 1) * 100;\n    \n                        if (winPercentAfter > winPercentBefore) {\n                            accuracy = 100\n                        } else {\n                            accuracy = Math.round(103.1668100711649 * Math.exp(-0.04354415386753951 * (winPercentBefore - winPercentAfter)) -3.166924740191411);\n                        }\n    \n                        scoreDiff = bestLineBefore.rawScore - bestLineAfter.rawScore;\n                        \n                        let wasOnlyMore = (\n                            // engine found more than one line\n                            linesBefore.length >= 2\n                            // the diff between the first line and seconde is high\n                            && linesBefore[0].rawScore > linesBefore[1].rawScore + 200\n                            // and we played the move\n                            && linesBefore[0].line.startsWith(move.cmove.lan)\n                        );\n                        \n                        console.log({ moveNumber: move.number, move, linesBefore, bestLineBefore, winPercentBefore, linesAfter, bestLineAfter, winPercentAfter, accuracy, scoreDiff });\n                        const newMove = {\n                            ...move,\n    \n                            scoreDiff: scoreDiff, // (linesBefore.length > 0 ? linesBefore[0].score : \"-\")\n                            accuracy: accuracy,\n            \n                            scoreBefore: bestLineBefore.rawScore,\n                            scoreAfter: bestLineAfter.rawScore,\n\n                            wasOnlyMore: wasOnlyMore,\n                        };\n    \n                        resolve(newMove);\n                    } else {\n                        resolve(move);\n                    }\n                });         \n            }); \n        });\n    }\n\n    return cache[move.id];\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}