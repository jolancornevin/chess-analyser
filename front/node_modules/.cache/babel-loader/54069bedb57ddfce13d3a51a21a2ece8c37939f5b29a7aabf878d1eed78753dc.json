{"ast":null,"code":"import { key2pos, createEl, posToTranslate as posToTranslateFromBounds, translate } from './util.js';\nimport { whitePov } from './board.js';\n// ported from https://github.com/lichess-org/lichobile/blob/master/src/chessground/render.ts\n// in case of bugs, blame @veloce\nexport function render(s) {\n  const asWhite = whitePov(s),\n    posToTranslate = posToTranslateFromBounds(s.dom.bounds()),\n    boardEl = s.dom.elements.board,\n    pieces = s.pieces,\n    curAnim = s.animation.current,\n    anims = curAnim ? curAnim.plan.anims : new Map(),\n    fadings = curAnim ? curAnim.plan.fadings : new Map(),\n    curDrag = s.draggable.current,\n    squares = computeSquareClasses(s),\n    samePieces = new Set(),\n    sameSquares = new Set(),\n    movedPieces = new Map(),\n    movedSquares = new Map(); // by class name\n  let k, el, pieceAtKey, elPieceName, anim, fading, pMvdset, pMvd, sMvdset, sMvd;\n  // walk over all board dom elements, apply animations and flag moved pieces\n  el = boardEl.firstChild;\n  while (el) {\n    k = el.cgKey;\n    if (isPieceNode(el)) {\n      pieceAtKey = pieces.get(k);\n      anim = anims.get(k);\n      fading = fadings.get(k);\n      elPieceName = el.cgPiece;\n      // if piece not being dragged anymore, remove dragging style\n      if (el.cgDragging && (!curDrag || curDrag.orig !== k)) {\n        el.classList.remove('dragging');\n        translate(el, posToTranslate(key2pos(k), asWhite));\n        el.cgDragging = false;\n      }\n      // remove fading class if it still remains\n      if (!fading && el.cgFading) {\n        el.cgFading = false;\n        el.classList.remove('fading');\n      }\n      // there is now a piece at this dom key\n      if (pieceAtKey) {\n        // continue animation if already animating and same piece\n        // (otherwise it could animate a captured piece)\n        if (anim && el.cgAnimating && elPieceName === pieceNameOf(pieceAtKey)) {\n          const pos = key2pos(k);\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n          el.classList.add('anim');\n          translate(el, posToTranslate(pos, asWhite));\n        } else if (el.cgAnimating) {\n          el.cgAnimating = false;\n          el.classList.remove('anim');\n          translate(el, posToTranslate(key2pos(k), asWhite));\n          if (s.addPieceZIndex) el.style.zIndex = posZIndex(key2pos(k), asWhite);\n        }\n        // same piece: flag as same\n        if (elPieceName === pieceNameOf(pieceAtKey) && (!fading || !el.cgFading)) {\n          samePieces.add(k);\n        }\n        // different piece: flag as moved unless it is a fading piece\n        else {\n          if (fading && elPieceName === pieceNameOf(fading)) {\n            el.classList.add('fading');\n            el.cgFading = true;\n          } else {\n            appendValue(movedPieces, elPieceName, el);\n          }\n        }\n      }\n      // no piece: flag as moved\n      else {\n        appendValue(movedPieces, elPieceName, el);\n      }\n    } else if (isSquareNode(el)) {\n      const cn = el.className;\n      if (squares.get(k) === cn) sameSquares.add(k);else appendValue(movedSquares, cn, el);\n    }\n    el = el.nextSibling;\n  }\n  // walk over all squares in current set, apply dom changes to moved squares\n  // or append new squares\n  for (const [sk, className] of squares) {\n    if (!sameSquares.has(sk)) {\n      sMvdset = movedSquares.get(className);\n      sMvd = sMvdset && sMvdset.pop();\n      const translation = posToTranslate(key2pos(sk), asWhite);\n      if (sMvd) {\n        sMvd.cgKey = sk;\n        translate(sMvd, translation);\n      } else {\n        const squareNode = createEl('square', className);\n        squareNode.cgKey = sk;\n        translate(squareNode, translation);\n        boardEl.insertBefore(squareNode, boardEl.firstChild);\n      }\n    }\n  }\n  // walk over all pieces in current set, apply dom changes to moved pieces\n  // or append new pieces\n  for (const [k, p] of pieces) {\n    anim = anims.get(k);\n    if (!samePieces.has(k)) {\n      pMvdset = movedPieces.get(pieceNameOf(p));\n      pMvd = pMvdset && pMvdset.pop();\n      // a same piece was moved\n      if (pMvd) {\n        // apply dom changes\n        pMvd.cgKey = k;\n        if (pMvd.cgFading) {\n          pMvd.classList.remove('fading');\n          pMvd.cgFading = false;\n        }\n        const pos = key2pos(k);\n        if (s.addPieceZIndex) pMvd.style.zIndex = posZIndex(pos, asWhite);\n        if (anim) {\n          pMvd.cgAnimating = true;\n          pMvd.classList.add('anim');\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n        }\n        translate(pMvd, posToTranslate(pos, asWhite));\n      }\n      // no piece in moved obj: insert the new piece\n      // assumes the new piece is not being dragged\n      else {\n        const pieceName = pieceNameOf(p),\n          pieceNode = createEl('piece', pieceName),\n          pos = key2pos(k);\n        pieceNode.cgPiece = pieceName;\n        pieceNode.cgKey = k;\n        if (anim) {\n          pieceNode.cgAnimating = true;\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n        }\n        translate(pieceNode, posToTranslate(pos, asWhite));\n        if (s.addPieceZIndex) pieceNode.style.zIndex = posZIndex(pos, asWhite);\n        boardEl.appendChild(pieceNode);\n      }\n    }\n  }\n  // remove any element that remains in the moved sets\n  for (const nodes of movedPieces.values()) removeNodes(s, nodes);\n  for (const nodes of movedSquares.values()) removeNodes(s, nodes);\n}\nexport function renderResized(s) {\n  const asWhite = whitePov(s),\n    posToTranslate = posToTranslateFromBounds(s.dom.bounds());\n  let el = s.dom.elements.board.firstChild;\n  while (el) {\n    if (isPieceNode(el) && !el.cgAnimating || isSquareNode(el)) {\n      translate(el, posToTranslate(key2pos(el.cgKey), asWhite));\n    }\n    el = el.nextSibling;\n  }\n}\nexport function updateBounds(s) {\n  var _a, _b;\n  const bounds = s.dom.elements.wrap.getBoundingClientRect();\n  const container = s.dom.elements.container;\n  const ratio = bounds.height / bounds.width;\n  const width = Math.floor(bounds.width * window.devicePixelRatio / 8) * 8 / window.devicePixelRatio;\n  const height = width * ratio;\n  container.style.width = width + 'px';\n  container.style.height = height + 'px';\n  s.dom.bounds.clear();\n  (_a = s.addDimensionsCssVarsTo) === null || _a === void 0 ? void 0 : _a.style.setProperty('--cg-width', width + 'px');\n  (_b = s.addDimensionsCssVarsTo) === null || _b === void 0 ? void 0 : _b.style.setProperty('--cg-height', height + 'px');\n}\nconst isPieceNode = el => el.tagName === 'PIECE';\nconst isSquareNode = el => el.tagName === 'SQUARE';\nfunction removeNodes(s, nodes) {\n  for (const node of nodes) s.dom.elements.board.removeChild(node);\n}\nfunction posZIndex(pos, asWhite) {\n  const minZ = 3;\n  const rank = pos[1];\n  const z = asWhite ? minZ + 7 - rank : minZ + rank;\n  return `${z}`;\n}\nconst pieceNameOf = piece => `${piece.color} ${piece.role}`;\nfunction computeSquareClasses(s) {\n  var _a;\n  const squares = new Map();\n  if (s.lastMove && s.highlight.lastMove) for (const k of s.lastMove) {\n    addSquare(squares, k, 'last-move');\n  }\n  if (s.check && s.highlight.check) addSquare(squares, s.check, 'check');\n  if (s.selected) {\n    addSquare(squares, s.selected, 'selected');\n    if (s.movable.showDests) {\n      const dests = (_a = s.movable.dests) === null || _a === void 0 ? void 0 : _a.get(s.selected);\n      if (dests) for (const k of dests) {\n        addSquare(squares, k, 'move-dest' + (s.pieces.has(k) ? ' oc' : ''));\n      }\n      const pDests = s.premovable.dests;\n      if (pDests) for (const k of pDests) {\n        addSquare(squares, k, 'premove-dest' + (s.pieces.has(k) ? ' oc' : ''));\n      }\n    }\n  }\n  const premove = s.premovable.current;\n  if (premove) for (const k of premove) addSquare(squares, k, 'current-premove');else if (s.predroppable.current) addSquare(squares, s.predroppable.current.key, 'current-premove');\n  const o = s.exploding;\n  if (o) for (const k of o.keys) addSquare(squares, k, 'exploding' + o.stage);\n  return squares;\n}\nfunction addSquare(squares, key, klass) {\n  const classes = squares.get(key);\n  if (classes) squares.set(key, `${classes} ${klass}`);else squares.set(key, klass);\n}\nfunction appendValue(map, key, value) {\n  const arr = map.get(key);\n  if (arr) arr.push(value);else map.set(key, [value]);\n}","map":{"version":3,"names":["key2pos","createEl","posToTranslate","posToTranslateFromBounds","translate","whitePov","render","s","asWhite","dom","bounds","boardEl","elements","board","pieces","curAnim","animation","current","anims","plan","Map","fadings","curDrag","draggable","squares","computeSquareClasses","samePieces","Set","sameSquares","movedPieces","movedSquares","k","el","pieceAtKey","elPieceName","anim","fading","pMvdset","pMvd","sMvdset","sMvd","firstChild","cgKey","isPieceNode","get","cgPiece","cgDragging","orig","classList","remove","cgFading","cgAnimating","pieceNameOf","pos","add","addPieceZIndex","style","zIndex","posZIndex","appendValue","isSquareNode","cn","className","nextSibling","sk","has","pop","translation","squareNode","insertBefore","p","pieceName","pieceNode","appendChild","nodes","values","removeNodes","renderResized","updateBounds","wrap","getBoundingClientRect","container","ratio","height","width","Math","floor","window","devicePixelRatio","clear","_a","addDimensionsCssVarsTo","setProperty","_b","tagName","node","removeChild","minZ","rank","z","piece","color","role","lastMove","highlight","addSquare","check","selected","movable","showDests","dests","pDests","premovable","premove","predroppable","key","o","exploding","keys","stage","klass","classes","set","map","value","arr","push"],"sources":["/Users/jcornevin/Dev/Perso/chess-analyser/node_modules/chessground/src/render.ts"],"sourcesContent":["import { State } from './state.js';\nimport { key2pos, createEl, posToTranslate as posToTranslateFromBounds, translate } from './util.js';\nimport { whitePov } from './board.js';\nimport { AnimCurrent, AnimVectors, AnimVector, AnimFadings } from './anim.js';\nimport { DragCurrent } from './drag.js';\nimport * as cg from './types.js';\n\ntype PieceName = string; // `$color $role`\n\ntype SquareClasses = Map<cg.Key, string>;\n\n// ported from https://github.com/lichess-org/lichobile/blob/master/src/chessground/render.ts\n// in case of bugs, blame @veloce\nexport function render(s: State): void {\n  const asWhite: boolean = whitePov(s),\n    posToTranslate = posToTranslateFromBounds(s.dom.bounds()),\n    boardEl: HTMLElement = s.dom.elements.board,\n    pieces: cg.Pieces = s.pieces,\n    curAnim: AnimCurrent | undefined = s.animation.current,\n    anims: AnimVectors = curAnim ? curAnim.plan.anims : new Map(),\n    fadings: AnimFadings = curAnim ? curAnim.plan.fadings : new Map(),\n    curDrag: DragCurrent | undefined = s.draggable.current,\n    squares: SquareClasses = computeSquareClasses(s),\n    samePieces: Set<cg.Key> = new Set(),\n    sameSquares: Set<cg.Key> = new Set(),\n    movedPieces: Map<PieceName, cg.PieceNode[]> = new Map(),\n    movedSquares: Map<string, cg.SquareNode[]> = new Map(); // by class name\n  let k: cg.Key,\n    el: cg.PieceNode | cg.SquareNode | undefined,\n    pieceAtKey: cg.Piece | undefined,\n    elPieceName: PieceName,\n    anim: AnimVector | undefined,\n    fading: cg.Piece | undefined,\n    pMvdset: cg.PieceNode[] | undefined,\n    pMvd: cg.PieceNode | undefined,\n    sMvdset: cg.SquareNode[] | undefined,\n    sMvd: cg.SquareNode | undefined;\n\n  // walk over all board dom elements, apply animations and flag moved pieces\n  el = boardEl.firstChild as cg.PieceNode | cg.SquareNode | undefined;\n  while (el) {\n    k = el.cgKey;\n    if (isPieceNode(el)) {\n      pieceAtKey = pieces.get(k);\n      anim = anims.get(k);\n      fading = fadings.get(k);\n      elPieceName = el.cgPiece;\n      // if piece not being dragged anymore, remove dragging style\n      if (el.cgDragging && (!curDrag || curDrag.orig !== k)) {\n        el.classList.remove('dragging');\n        translate(el, posToTranslate(key2pos(k), asWhite));\n        el.cgDragging = false;\n      }\n      // remove fading class if it still remains\n      if (!fading && el.cgFading) {\n        el.cgFading = false;\n        el.classList.remove('fading');\n      }\n      // there is now a piece at this dom key\n      if (pieceAtKey) {\n        // continue animation if already animating and same piece\n        // (otherwise it could animate a captured piece)\n        if (anim && el.cgAnimating && elPieceName === pieceNameOf(pieceAtKey)) {\n          const pos = key2pos(k);\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n          el.classList.add('anim');\n          translate(el, posToTranslate(pos, asWhite));\n        } else if (el.cgAnimating) {\n          el.cgAnimating = false;\n          el.classList.remove('anim');\n          translate(el, posToTranslate(key2pos(k), asWhite));\n          if (s.addPieceZIndex) el.style.zIndex = posZIndex(key2pos(k), asWhite);\n        }\n        // same piece: flag as same\n        if (elPieceName === pieceNameOf(pieceAtKey) && (!fading || !el.cgFading)) {\n          samePieces.add(k);\n        }\n        // different piece: flag as moved unless it is a fading piece\n        else {\n          if (fading && elPieceName === pieceNameOf(fading)) {\n            el.classList.add('fading');\n            el.cgFading = true;\n          } else {\n            appendValue(movedPieces, elPieceName, el);\n          }\n        }\n      }\n      // no piece: flag as moved\n      else {\n        appendValue(movedPieces, elPieceName, el);\n      }\n    } else if (isSquareNode(el)) {\n      const cn = el.className;\n      if (squares.get(k) === cn) sameSquares.add(k);\n      else appendValue(movedSquares, cn, el);\n    }\n    el = el.nextSibling as cg.PieceNode | cg.SquareNode | undefined;\n  }\n\n  // walk over all squares in current set, apply dom changes to moved squares\n  // or append new squares\n  for (const [sk, className] of squares) {\n    if (!sameSquares.has(sk)) {\n      sMvdset = movedSquares.get(className);\n      sMvd = sMvdset && sMvdset.pop();\n      const translation = posToTranslate(key2pos(sk), asWhite);\n      if (sMvd) {\n        sMvd.cgKey = sk;\n        translate(sMvd, translation);\n      } else {\n        const squareNode = createEl('square', className) as cg.SquareNode;\n        squareNode.cgKey = sk;\n        translate(squareNode, translation);\n        boardEl.insertBefore(squareNode, boardEl.firstChild);\n      }\n    }\n  }\n\n  // walk over all pieces in current set, apply dom changes to moved pieces\n  // or append new pieces\n  for (const [k, p] of pieces) {\n    anim = anims.get(k);\n    if (!samePieces.has(k)) {\n      pMvdset = movedPieces.get(pieceNameOf(p));\n      pMvd = pMvdset && pMvdset.pop();\n      // a same piece was moved\n      if (pMvd) {\n        // apply dom changes\n        pMvd.cgKey = k;\n        if (pMvd.cgFading) {\n          pMvd.classList.remove('fading');\n          pMvd.cgFading = false;\n        }\n        const pos = key2pos(k);\n        if (s.addPieceZIndex) pMvd.style.zIndex = posZIndex(pos, asWhite);\n        if (anim) {\n          pMvd.cgAnimating = true;\n          pMvd.classList.add('anim');\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n        }\n        translate(pMvd, posToTranslate(pos, asWhite));\n      }\n      // no piece in moved obj: insert the new piece\n      // assumes the new piece is not being dragged\n      else {\n        const pieceName = pieceNameOf(p),\n          pieceNode = createEl('piece', pieceName) as cg.PieceNode,\n          pos = key2pos(k);\n\n        pieceNode.cgPiece = pieceName;\n        pieceNode.cgKey = k;\n        if (anim) {\n          pieceNode.cgAnimating = true;\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n        }\n        translate(pieceNode, posToTranslate(pos, asWhite));\n\n        if (s.addPieceZIndex) pieceNode.style.zIndex = posZIndex(pos, asWhite);\n\n        boardEl.appendChild(pieceNode);\n      }\n    }\n  }\n\n  // remove any element that remains in the moved sets\n  for (const nodes of movedPieces.values()) removeNodes(s, nodes);\n  for (const nodes of movedSquares.values()) removeNodes(s, nodes);\n}\n\nexport function renderResized(s: State): void {\n  const asWhite: boolean = whitePov(s),\n    posToTranslate = posToTranslateFromBounds(s.dom.bounds());\n  let el = s.dom.elements.board.firstChild as cg.PieceNode | cg.SquareNode | undefined;\n  while (el) {\n    if ((isPieceNode(el) && !el.cgAnimating) || isSquareNode(el)) {\n      translate(el, posToTranslate(key2pos(el.cgKey), asWhite));\n    }\n    el = el.nextSibling as cg.PieceNode | cg.SquareNode | undefined;\n  }\n}\n\nexport function updateBounds(s: State): void {\n  const bounds = s.dom.elements.wrap.getBoundingClientRect();\n  const container = s.dom.elements.container;\n  const ratio = bounds.height / bounds.width;\n  const width = (Math.floor((bounds.width * window.devicePixelRatio) / 8) * 8) / window.devicePixelRatio;\n  const height = width * ratio;\n  container.style.width = width + 'px';\n  container.style.height = height + 'px';\n  s.dom.bounds.clear();\n\n  s.addDimensionsCssVarsTo?.style.setProperty('--cg-width', width + 'px');\n  s.addDimensionsCssVarsTo?.style.setProperty('--cg-height', height + 'px');\n}\n\nconst isPieceNode = (el: cg.PieceNode | cg.SquareNode): el is cg.PieceNode => el.tagName === 'PIECE';\nconst isSquareNode = (el: cg.PieceNode | cg.SquareNode): el is cg.SquareNode => el.tagName === 'SQUARE';\n\nfunction removeNodes(s: State, nodes: HTMLElement[]): void {\n  for (const node of nodes) s.dom.elements.board.removeChild(node);\n}\n\nfunction posZIndex(pos: cg.Pos, asWhite: boolean): string {\n  const minZ = 3;\n  const rank = pos[1];\n  const z = asWhite ? minZ + 7 - rank : minZ + rank;\n\n  return `${z}`;\n}\n\nconst pieceNameOf = (piece: cg.Piece): string => `${piece.color} ${piece.role}`;\n\nfunction computeSquareClasses(s: State): SquareClasses {\n  const squares: SquareClasses = new Map();\n  if (s.lastMove && s.highlight.lastMove)\n    for (const k of s.lastMove) {\n      addSquare(squares, k, 'last-move');\n    }\n  if (s.check && s.highlight.check) addSquare(squares, s.check, 'check');\n  if (s.selected) {\n    addSquare(squares, s.selected, 'selected');\n    if (s.movable.showDests) {\n      const dests = s.movable.dests?.get(s.selected);\n      if (dests)\n        for (const k of dests) {\n          addSquare(squares, k, 'move-dest' + (s.pieces.has(k) ? ' oc' : ''));\n        }\n      const pDests = s.premovable.dests;\n      if (pDests)\n        for (const k of pDests) {\n          addSquare(squares, k, 'premove-dest' + (s.pieces.has(k) ? ' oc' : ''));\n        }\n    }\n  }\n  const premove = s.premovable.current;\n  if (premove) for (const k of premove) addSquare(squares, k, 'current-premove');\n  else if (s.predroppable.current) addSquare(squares, s.predroppable.current.key, 'current-premove');\n\n  const o = s.exploding;\n  if (o) for (const k of o.keys) addSquare(squares, k, 'exploding' + o.stage);\n\n  return squares;\n}\n\nfunction addSquare(squares: SquareClasses, key: cg.Key, klass: string): void {\n  const classes = squares.get(key);\n  if (classes) squares.set(key, `${classes} ${klass}`);\n  else squares.set(key, klass);\n}\n\nfunction appendValue<K, V>(map: Map<K, V[]>, key: K, value: V): void {\n  const arr = map.get(key);\n  if (arr) arr.push(value);\n  else map.set(key, [value]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}