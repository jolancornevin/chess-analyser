{"ast":null,"code":"// append and remove only. No updates.\nexport function syncShapes(shapes, root, renderShape) {\n  const hashesInDom = new Map(),\n    // by hash\n    toRemove = [];\n  for (const sc of shapes) hashesInDom.set(sc.hash, false);\n  let el = root.firstChild,\n    elHash;\n  while (el) {\n    elHash = el.getAttribute('cgHash');\n    // found a shape element that's here to stay\n    if (hashesInDom.has(elHash)) hashesInDom.set(elHash, true);\n    // or remove it\n    else toRemove.push(el);\n    el = el.nextSibling;\n  }\n  // remove old shapes\n  for (const el of toRemove) root.removeChild(el);\n  // insert shapes that are not yet in dom\n  for (const sc of shapes) {\n    if (!hashesInDom.get(sc.hash)) root.appendChild(renderShape(sc));\n  }\n}","map":{"version":3,"names":["syncShapes","shapes","root","renderShape","hashesInDom","Map","toRemove","sc","set","hash","el","firstChild","elHash","getAttribute","has","push","nextSibling","removeChild","get","appendChild"],"sources":["/Users/jcornevin/Dev/Perso/chess-analyser/node_modules/chessground/src/sync.ts"],"sourcesContent":["import { DrawShape } from './draw';\n\nexport interface SyncableShape {\n  shape: DrawShape;\n  current: boolean;\n  hash: Hash;\n}\n\nexport type Hash = string;\n\n// append and remove only. No updates.\nexport function syncShapes(\n  shapes: SyncableShape[],\n  root: HTMLElement | SVGElement,\n  renderShape: (shape: SyncableShape) => HTMLElement | SVGElement\n): void {\n  const hashesInDom = new Map(), // by hash\n    toRemove: SVGElement[] = [];\n  for (const sc of shapes) hashesInDom.set(sc.hash, false);\n  let el: SVGElement | undefined = root.firstChild as SVGElement,\n    elHash: Hash | null;\n  while (el) {\n    elHash = el.getAttribute('cgHash') as Hash;\n    // found a shape element that's here to stay\n    if (hashesInDom.has(elHash)) hashesInDom.set(elHash, true);\n    // or remove it\n    else toRemove.push(el);\n    el = el.nextSibling as SVGElement | undefined;\n  }\n  // remove old shapes\n  for (const el of toRemove) root.removeChild(el);\n  // insert shapes that are not yet in dom\n  for (const sc of shapes) {\n    if (!hashesInDom.get(sc.hash)) root.appendChild(renderShape(sc));\n  }\n}\n"],"mappings":"AAUA;AACA,OAAM,SAAUA,UAAUA,CACxBC,MAAuB,EACvBC,IAA8B,EAC9BC,WAA+D;EAE/D,MAAMC,WAAW,GAAG,IAAIC,GAAG,EAAE;IAAE;IAC7BC,QAAQ,GAAiB,EAAE;EAC7B,KAAK,MAAMC,EAAE,IAAIN,MAAM,EAAEG,WAAW,CAACI,GAAG,CAACD,EAAE,CAACE,IAAI,EAAE,KAAK,CAAC;EACxD,IAAIC,EAAE,GAA2BR,IAAI,CAACS,UAAwB;IAC5DC,MAAmB;EACrB,OAAOF,EAAE,EAAE;IACTE,MAAM,GAAGF,EAAE,CAACG,YAAY,CAAC,QAAQ,CAAS;IAC1C;IACA,IAAIT,WAAW,CAACU,GAAG,CAACF,MAAM,CAAC,EAAER,WAAW,CAACI,GAAG,CAACI,MAAM,EAAE,IAAI,CAAC;IAC1D;IAAA,KACKN,QAAQ,CAACS,IAAI,CAACL,EAAE,CAAC;IACtBA,EAAE,GAAGA,EAAE,CAACM,WAAqC;;EAE/C;EACA,KAAK,MAAMN,EAAE,IAAIJ,QAAQ,EAAEJ,IAAI,CAACe,WAAW,CAACP,EAAE,CAAC;EAC/C;EACA,KAAK,MAAMH,EAAE,IAAIN,MAAM,EAAE;IACvB,IAAI,CAACG,WAAW,CAACc,GAAG,CAACX,EAAE,CAACE,IAAI,CAAC,EAAEP,IAAI,CAACiB,WAAW,CAAChB,WAAW,CAACI,EAAE,CAAC,CAAC;;AAEpE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}