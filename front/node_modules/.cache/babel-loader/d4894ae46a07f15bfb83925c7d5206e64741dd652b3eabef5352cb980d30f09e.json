{"ast":null,"code":"import { engineEval } from './right-menu/engine';\nexport function NewLine(rawScore, scoreType, line, win, draw, lose) {\n  const isMate = scoreType === \"mate\";\n  const score = isMate ? rawScore : rawScore / 100;\n  return {\n    score: `${isMate ? \"M\" : \"\"}${score}`,\n    // in pawns\n    rawScore,\n    // in centipawns\n    scoreType,\n    line,\n    win,\n    draw,\n    lose\n  };\n}\n_c = NewLine;\nexport function NewMove(id, value, moveNumber) {\n  return {\n    id: id,\n    to: value.to,\n    fen: value.after,\n    number: moveNumber,\n    cmove: value,\n    scoreComputed: false\n  };\n}\n_c2 = NewMove;\nlet cache = {};\nexport function resetEngineCache() {\n  cache = {};\n}\nexport async function ComputeMoveScore(move) {\n  if (!cache[move.id]) {\n    cache[move.id] = new Promise(async (resolve, reject) => {\n      console.log(\"computing for real for \", move.id);\n      await engineEval(move.cmove.before, 3).then(async linesBefore => {\n        await engineEval(move.cmove.after, 3).then(linesAfter => {\n          let accuracy = 0;\n          let scoreDiff = 0;\n\n          // console.log(`>>>> got scores for move ${move.to} with ${move.cmove.before} and ${move.cmove.after}`);\n\n          if (linesBefore.length > 0 && linesAfter.length > 0) {\n            const bestLineBefore = linesBefore[0];\n\n            // taking the last one because we want the best line for our opponent\n            const bestLineAfter = linesAfter[0];\n            // Addition to take the perspective of the player playing, so we reverse the score.\n            // if we're white, the line after give a score for black, which will be negative if good for us.\n            bestLineAfter.rawScore *= -1;\n            const winPercentBefore = (2 / (1 + Math.exp(-0.00368208 * bestLineBefore.rawScore)) - 1) * 100;\n            const winPercentAfter = (2 / (1 + Math.exp(-0.00368208 * bestLineAfter.rawScore)) - 1) * 100;\n            if (winPercentAfter > winPercentBefore) {\n              accuracy = 100;\n            } else {\n              accuracy = Math.round(103.1668100711649 * Math.exp(-0.04354415386753951 * (winPercentBefore - winPercentAfter)) - 3.166924740191411);\n            }\n            scoreDiff = bestLineBefore.rawScore - bestLineAfter.rawScore;\n            let wasOnlyMove =\n            // engine found more than one line\n            linesBefore.length >= 2\n            // the diff between the first line and seconde is high\n            && linesBefore[0].rawScore > linesBefore[1].rawScore + 200;\n            let playedOnlyMove = wasOnlyMove\n            // and we played the move\n            && linesBefore[0].line.startsWith(move.cmove.lan);\n            console.log({\n              moveNumber: move.number,\n              move,\n              linesBefore,\n              bestLineBefore,\n              winPercentBefore,\n              linesAfter,\n              bestLineAfter,\n              winPercentAfter,\n              accuracy,\n              scoreDiff\n            });\n            const newMove = {\n              ...move,\n              scoreComputed: true,\n              scoreDiff: scoreDiff,\n              // (linesBefore.length > 0 ? linesBefore[0].score : \"-\")\n              accuracy: accuracy,\n              scoreBefore: bestLineBefore.rawScore,\n              scoreAfter: bestLineAfter.rawScore,\n              wasOnlyMove: wasOnlyMove,\n              playedOnlyMove: playedOnlyMove\n            };\n            resolve(newMove);\n          } else {\n            resolve(move);\n          }\n        });\n      });\n    });\n  }\n  return cache[move.id];\n}\n_c3 = ComputeMoveScore;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"NewLine\");\n$RefreshReg$(_c2, \"NewMove\");\n$RefreshReg$(_c3, \"ComputeMoveScore\");","map":{"version":3,"names":["engineEval","NewLine","rawScore","scoreType","line","win","draw","lose","isMate","score","_c","NewMove","id","value","moveNumber","to","fen","after","number","cmove","scoreComputed","_c2","cache","resetEngineCache","ComputeMoveScore","move","Promise","resolve","reject","console","log","before","then","linesBefore","linesAfter","accuracy","scoreDiff","length","bestLineBefore","bestLineAfter","winPercentBefore","Math","exp","winPercentAfter","round","wasOnlyMove","playedOnlyMove","startsWith","lan","newMove","scoreBefore","scoreAfter","_c3","$RefreshReg$"],"sources":["/Users/jcornevin/Dev/Perso/chess-analyser/src/components/types.ts"],"sourcesContent":["\nimport { Move as cMove } from 'chess.js';\nimport { engineEval } from './right-menu/engine';\n\n\nexport interface Line {\n    line: string;\n\n    scoreType: string;\n\n    rawScore: number;\n    score: string;\n\n    win: number;\n    draw: number;\n    lose: number;\n}\n\nexport function NewLine(rawScore, scoreType, line, win, draw, lose): Line {\n    const isMate = scoreType === \"mate\";\n    const score = isMate ? rawScore : rawScore / 100;\n    \n    return {\n        score: `${isMate ? \"M\" : \"\"}${score}`, // in pawns\n        rawScore, // in centipawns\n        scoreType,\n        line,\n\n        win, draw, lose\n    } \n}\n\nexport interface Move {\n    id: number;\n\n    number: number;\n    to: string; // move (d4)\n    fen: string;\n    \n    scoreComputed: boolean;\n\n    cmove?: cMove;\n    scoreDiff?: number;\n    accuracy?: number;\n\n    scoreBefore?: number;\n    scoreAfter?: number;\n\n    wasOnlyMove?: boolean;\n    playedOnlyMove?: boolean;\n}\n\nexport function NewMove(id: number, value: cMove, moveNumber: number): Move {\n    return {\n        id: id,\n\n        to: value.to,\n        fen: value.after,\n        number: moveNumber,\n        cmove: value,\n\n        scoreComputed: false,\n    }\n}\n\nlet cache = {};\n\nexport function resetEngineCache() {\n    cache = {};\n}\n\nexport async function ComputeMoveScore(move: Move): Promise<Move> {   \n    if (!cache[move.id]) {\n        cache[move.id] = new Promise(async (resolve, reject) => {\n            console.log(\"computing for real for \", move.id)\n            await engineEval(move.cmove.before, 3).then(async (linesBefore) => {\n                await engineEval(move.cmove.after, 3).then((linesAfter) => {\n                    let accuracy = 0;\n                    let scoreDiff = 0;\n    \n                    // console.log(`>>>> got scores for move ${move.to} with ${move.cmove.before} and ${move.cmove.after}`);\n    \n                    if (linesBefore.length > 0 && linesAfter.length > 0) {\n                        const bestLineBefore = linesBefore[0];\n    \n                        // taking the last one because we want the best line for our opponent\n                        const bestLineAfter = linesAfter[0];\n                        // Addition to take the perspective of the player playing, so we reverse the score.\n                        // if we're white, the line after give a score for black, which will be negative if good for us.\n                        bestLineAfter.rawScore *= -1;\n                        \n                        const winPercentBefore = (2 / (1 + Math.exp(-0.00368208 * bestLineBefore.rawScore)) - 1) * 100;\n                        const winPercentAfter = (2 / (1 + Math.exp(-0.00368208 * bestLineAfter.rawScore)) - 1) * 100;\n    \n                        if (winPercentAfter > winPercentBefore) {\n                            accuracy = 100\n                        } else {\n                            accuracy = Math.round(103.1668100711649 * Math.exp(-0.04354415386753951 * (winPercentBefore - winPercentAfter)) -3.166924740191411);\n                        }\n    \n                        scoreDiff = bestLineBefore.rawScore - bestLineAfter.rawScore;\n                        \n                        let wasOnlyMove = (\n                            // engine found more than one line\n                            linesBefore.length >= 2\n                            // the diff between the first line and seconde is high\n                            && linesBefore[0].rawScore > linesBefore[1].rawScore + 200\n                        );\n                        \n                        let playedOnlyMove = (\n                            wasOnlyMove\n                            // and we played the move\n                            && linesBefore[0].line.startsWith(move.cmove.lan)\n                        );\n                        \n                        console.log({ moveNumber: move.number, move, linesBefore, bestLineBefore, winPercentBefore, linesAfter, bestLineAfter, winPercentAfter, accuracy, scoreDiff });\n                        const newMove = {\n                            ...move,\n    \n                            scoreComputed: true,\n\n                            scoreDiff: scoreDiff, // (linesBefore.length > 0 ? linesBefore[0].score : \"-\")\n                            accuracy: accuracy,\n            \n                            scoreBefore: bestLineBefore.rawScore,\n                            scoreAfter: bestLineAfter.rawScore,\n\n                            wasOnlyMove: wasOnlyMove,\n                            playedOnlyMove: playedOnlyMove,\n                        };\n    \n                        resolve(newMove);\n                    } else {\n                        resolve(move);\n                    }\n                });         \n            }); \n        });\n    }\n\n    return cache[move.id];\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}