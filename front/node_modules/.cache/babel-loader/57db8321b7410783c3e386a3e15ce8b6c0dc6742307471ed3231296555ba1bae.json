{"ast":null,"code":"import * as board from './board.js';\nimport * as util from './util.js';\nimport { clear as drawClear } from './draw.js';\nimport { anim } from './anim.js';\nexport function start(s, e) {\n  if (!e.isTrusted || e.button !== undefined && e.button !== 0) return; // only touch or left click\n  if (e.touches && e.touches.length > 1) return; // support one finger touch only\n  const bounds = s.dom.bounds(),\n    position = util.eventPosition(e),\n    orig = board.getKeyAtDomPos(position, board.whitePov(s), bounds);\n  if (!orig) return;\n  const piece = s.pieces.get(orig);\n  const previouslySelected = s.selected;\n  if (!previouslySelected && s.drawable.enabled && (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor)) drawClear(s);\n  // Prevent touch scroll and create no corresponding mouse event, if there\n  // is an intent to interact with the board.\n  if (e.cancelable !== false && (!e.touches || s.blockTouchScroll || piece || previouslySelected || pieceCloseTo(s, position))) e.preventDefault();\n  const hadPremove = !!s.premovable.current;\n  const hadPredrop = !!s.predroppable.current;\n  s.stats.ctrlKey = e.ctrlKey;\n  if (s.selected && board.canMove(s, s.selected, orig)) {\n    anim(state => board.selectSquare(state, orig), s);\n  } else {\n    board.selectSquare(s, orig);\n  }\n  const stillSelected = s.selected === orig;\n  const element = pieceElementByKey(s, orig);\n  if (piece && element && stillSelected && board.isDraggable(s, orig)) {\n    s.draggable.current = {\n      orig,\n      piece,\n      origPos: position,\n      pos: position,\n      started: s.draggable.autoDistance && s.stats.dragged,\n      element,\n      previouslySelected,\n      originTarget: e.target,\n      keyHasChanged: false\n    };\n    element.cgDragging = true;\n    element.classList.add('dragging');\n    // place ghost\n    const ghost = s.dom.elements.ghost;\n    if (ghost) {\n      ghost.className = `ghost ${piece.color} ${piece.role}`;\n      util.translate(ghost, util.posToTranslate(bounds)(util.key2pos(orig), board.whitePov(s)));\n      util.setVisible(ghost, true);\n    }\n    processDrag(s);\n  } else {\n    if (hadPremove) board.unsetPremove(s);\n    if (hadPredrop) board.unsetPredrop(s);\n  }\n  s.dom.redraw();\n}\nfunction pieceCloseTo(s, pos) {\n  const asWhite = board.whitePov(s),\n    bounds = s.dom.bounds(),\n    radiusSq = Math.pow(bounds.width / 8, 2);\n  for (const key of s.pieces.keys()) {\n    const center = util.computeSquareCenter(key, asWhite, bounds);\n    if (util.distanceSq(center, pos) <= radiusSq) return true;\n  }\n  return false;\n}\nexport function dragNewPiece(s, piece, e, force) {\n  const key = 'a0';\n  s.pieces.set(key, piece);\n  s.dom.redraw();\n  const position = util.eventPosition(e);\n  s.draggable.current = {\n    orig: key,\n    piece,\n    origPos: position,\n    pos: position,\n    started: true,\n    element: () => pieceElementByKey(s, key),\n    originTarget: e.target,\n    newPiece: true,\n    force: !!force,\n    keyHasChanged: false\n  };\n  processDrag(s);\n}\nfunction processDrag(s) {\n  requestAnimationFrame(() => {\n    var _a;\n    const cur = s.draggable.current;\n    if (!cur) return;\n    // cancel animations while dragging\n    if ((_a = s.animation.current) === null || _a === void 0 ? void 0 : _a.plan.anims.has(cur.orig)) s.animation.current = undefined;\n    // if moving piece is gone, cancel\n    const origPiece = s.pieces.get(cur.orig);\n    if (!origPiece || !util.samePiece(origPiece, cur.piece)) cancel(s);else {\n      if (!cur.started && util.distanceSq(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2)) cur.started = true;\n      if (cur.started) {\n        // support lazy elements\n        if (typeof cur.element === 'function') {\n          const found = cur.element();\n          if (!found) return;\n          found.cgDragging = true;\n          found.classList.add('dragging');\n          cur.element = found;\n        }\n        const bounds = s.dom.bounds();\n        util.translate(cur.element, [cur.pos[0] - bounds.left - bounds.width / 16, cur.pos[1] - bounds.top - bounds.height / 16]);\n        cur.keyHasChanged || (cur.keyHasChanged = cur.orig !== board.getKeyAtDomPos(cur.pos, board.whitePov(s), bounds));\n      }\n    }\n    processDrag(s);\n  });\n}\nexport function move(s, e) {\n  // support one finger touch only\n  if (s.draggable.current && (!e.touches || e.touches.length < 2)) {\n    s.draggable.current.pos = util.eventPosition(e);\n  }\n}\nexport function end(s, e) {\n  const cur = s.draggable.current;\n  if (!cur) return;\n  // create no corresponding mouse event\n  if (e.type === 'touchend' && e.cancelable !== false) e.preventDefault();\n  // comparing with the origin target is an easy way to test that the end event\n  // has the same touch origin\n  if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {\n    s.draggable.current = undefined;\n    return;\n  }\n  board.unsetPremove(s);\n  board.unsetPredrop(s);\n  // touchend has no position; so use the last touchmove position instead\n  const eventPos = util.eventPosition(e) || cur.pos;\n  const dest = board.getKeyAtDomPos(eventPos, board.whitePov(s), s.dom.bounds());\n  if (dest && cur.started && cur.orig !== dest) {\n    if (cur.newPiece) board.dropNewPiece(s, cur.orig, dest, cur.force);else {\n      s.stats.ctrlKey = e.ctrlKey;\n      if (board.userMove(s, cur.orig, dest)) s.stats.dragged = true;\n    }\n  } else if (cur.newPiece) {\n    s.pieces.delete(cur.orig);\n  } else if (s.draggable.deleteOnDropOff && !dest) {\n    s.pieces.delete(cur.orig);\n    board.callUserFunction(s.events.change);\n  }\n  if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest)) board.unselect(s);else if (!s.selectable.enabled) board.unselect(s);\n  removeDragElements(s);\n  s.draggable.current = undefined;\n  s.dom.redraw();\n}\nexport function cancel(s) {\n  const cur = s.draggable.current;\n  if (cur) {\n    if (cur.newPiece) s.pieces.delete(cur.orig);\n    s.draggable.current = undefined;\n    board.unselect(s);\n    removeDragElements(s);\n    s.dom.redraw();\n  }\n}\nfunction removeDragElements(s) {\n  const e = s.dom.elements;\n  if (e.ghost) util.setVisible(e.ghost, false);\n}\nfunction pieceElementByKey(s, key) {\n  let el = s.dom.elements.board.firstChild;\n  while (el) {\n    if (el.cgKey === key && el.tagName === 'PIECE') return el;\n    el = el.nextSibling;\n  }\n  return;\n}","map":{"version":3,"names":["board","util","clear","drawClear","anim","start","s","e","isTrusted","button","undefined","touches","length","bounds","dom","position","eventPosition","orig","getKeyAtDomPos","whitePov","piece","pieces","get","previouslySelected","selected","drawable","enabled","eraseOnClick","color","turnColor","cancelable","blockTouchScroll","pieceCloseTo","preventDefault","hadPremove","premovable","current","hadPredrop","predroppable","stats","ctrlKey","canMove","state","selectSquare","stillSelected","element","pieceElementByKey","isDraggable","draggable","origPos","pos","started","autoDistance","dragged","originTarget","target","keyHasChanged","cgDragging","classList","add","ghost","elements","className","role","translate","posToTranslate","key2pos","setVisible","processDrag","unsetPremove","unsetPredrop","redraw","asWhite","radiusSq","Math","pow","width","key","keys","center","computeSquareCenter","distanceSq","dragNewPiece","force","set","newPiece","requestAnimationFrame","cur","_a","animation","plan","anims","has","origPiece","samePiece","cancel","distance","found","left","top","height","move","end","type","eventPos","dest","dropNewPiece","userMove","delete","deleteOnDropOff","callUserFunction","events","change","unselect","selectable","removeDragElements","el","firstChild","cgKey","tagName","nextSibling"],"sources":["/Users/jcornevin/Dev/Perso/chess-analyser/node_modules/chessground/src/drag.ts"],"sourcesContent":["import { State } from './state.js';\nimport * as board from './board.js';\nimport * as util from './util.js';\nimport { clear as drawClear } from './draw.js';\nimport * as cg from './types.js';\nimport { anim } from './anim.js';\n\nexport interface DragCurrent {\n  orig: cg.Key; // orig key of dragging piece\n  piece: cg.Piece;\n  origPos: cg.NumberPair; // first event position\n  pos: cg.NumberPair; // latest event position\n  started: boolean; // whether the drag has started; as per the distance setting\n  element: cg.PieceNode | (() => cg.PieceNode | undefined);\n  newPiece?: boolean; // it it a new piece from outside the board\n  force?: boolean; // can the new piece replace an existing one (editor)\n  previouslySelected?: cg.Key;\n  originTarget: EventTarget | null;\n  keyHasChanged: boolean; // whether the drag has left the orig key\n}\n\nexport function start(s: State, e: cg.MouchEvent): void {\n  if (!e.isTrusted || (e.button !== undefined && e.button !== 0)) return; // only touch or left click\n  if (e.touches && e.touches.length > 1) return; // support one finger touch only\n  const bounds = s.dom.bounds(),\n    position = util.eventPosition(e)!,\n    orig = board.getKeyAtDomPos(position, board.whitePov(s), bounds);\n  if (!orig) return;\n  const piece = s.pieces.get(orig);\n  const previouslySelected = s.selected;\n  if (!previouslySelected && s.drawable.enabled && (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor))\n    drawClear(s);\n  // Prevent touch scroll and create no corresponding mouse event, if there\n  // is an intent to interact with the board.\n  if (\n    e.cancelable !== false &&\n    (!e.touches || s.blockTouchScroll || piece || previouslySelected || pieceCloseTo(s, position))\n  )\n    e.preventDefault();\n  const hadPremove = !!s.premovable.current;\n  const hadPredrop = !!s.predroppable.current;\n  s.stats.ctrlKey = e.ctrlKey;\n  if (s.selected && board.canMove(s, s.selected, orig)) {\n    anim(state => board.selectSquare(state, orig), s);\n  } else {\n    board.selectSquare(s, orig);\n  }\n  const stillSelected = s.selected === orig;\n  const element = pieceElementByKey(s, orig);\n  if (piece && element && stillSelected && board.isDraggable(s, orig)) {\n    s.draggable.current = {\n      orig,\n      piece,\n      origPos: position,\n      pos: position,\n      started: s.draggable.autoDistance && s.stats.dragged,\n      element,\n      previouslySelected,\n      originTarget: e.target,\n      keyHasChanged: false,\n    };\n    element.cgDragging = true;\n    element.classList.add('dragging');\n    // place ghost\n    const ghost = s.dom.elements.ghost;\n    if (ghost) {\n      ghost.className = `ghost ${piece.color} ${piece.role}`;\n      util.translate(ghost, util.posToTranslate(bounds)(util.key2pos(orig), board.whitePov(s)));\n      util.setVisible(ghost, true);\n    }\n    processDrag(s);\n  } else {\n    if (hadPremove) board.unsetPremove(s);\n    if (hadPredrop) board.unsetPredrop(s);\n  }\n  s.dom.redraw();\n}\n\nfunction pieceCloseTo(s: State, pos: cg.NumberPair): boolean {\n  const asWhite = board.whitePov(s),\n    bounds = s.dom.bounds(),\n    radiusSq = Math.pow(bounds.width / 8, 2);\n  for (const key of s.pieces.keys()) {\n    const center = util.computeSquareCenter(key, asWhite, bounds);\n    if (util.distanceSq(center, pos) <= radiusSq) return true;\n  }\n  return false;\n}\n\nexport function dragNewPiece(s: State, piece: cg.Piece, e: cg.MouchEvent, force?: boolean): void {\n  const key: cg.Key = 'a0';\n  s.pieces.set(key, piece);\n  s.dom.redraw();\n\n  const position = util.eventPosition(e)!;\n\n  s.draggable.current = {\n    orig: key,\n    piece,\n    origPos: position,\n    pos: position,\n    started: true,\n    element: () => pieceElementByKey(s, key),\n    originTarget: e.target,\n    newPiece: true,\n    force: !!force,\n    keyHasChanged: false,\n  };\n  processDrag(s);\n}\n\nfunction processDrag(s: State): void {\n  requestAnimationFrame(() => {\n    const cur = s.draggable.current;\n    if (!cur) return;\n    // cancel animations while dragging\n    if (s.animation.current?.plan.anims.has(cur.orig)) s.animation.current = undefined;\n    // if moving piece is gone, cancel\n    const origPiece = s.pieces.get(cur.orig);\n    if (!origPiece || !util.samePiece(origPiece, cur.piece)) cancel(s);\n    else {\n      if (!cur.started && util.distanceSq(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2))\n        cur.started = true;\n      if (cur.started) {\n        // support lazy elements\n        if (typeof cur.element === 'function') {\n          const found = cur.element();\n          if (!found) return;\n          found.cgDragging = true;\n          found.classList.add('dragging');\n          cur.element = found;\n        }\n\n        const bounds = s.dom.bounds();\n        util.translate(cur.element, [\n          cur.pos[0] - bounds.left - bounds.width / 16,\n          cur.pos[1] - bounds.top - bounds.height / 16,\n        ]);\n\n        cur.keyHasChanged ||= cur.orig !== board.getKeyAtDomPos(cur.pos, board.whitePov(s), bounds);\n      }\n    }\n    processDrag(s);\n  });\n}\n\nexport function move(s: State, e: cg.MouchEvent): void {\n  // support one finger touch only\n  if (s.draggable.current && (!e.touches || e.touches.length < 2)) {\n    s.draggable.current.pos = util.eventPosition(e)!;\n  }\n}\n\nexport function end(s: State, e: cg.MouchEvent): void {\n  const cur = s.draggable.current;\n  if (!cur) return;\n  // create no corresponding mouse event\n  if (e.type === 'touchend' && e.cancelable !== false) e.preventDefault();\n  // comparing with the origin target is an easy way to test that the end event\n  // has the same touch origin\n  if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {\n    s.draggable.current = undefined;\n    return;\n  }\n  board.unsetPremove(s);\n  board.unsetPredrop(s);\n  // touchend has no position; so use the last touchmove position instead\n  const eventPos = util.eventPosition(e) || cur.pos;\n  const dest = board.getKeyAtDomPos(eventPos, board.whitePov(s), s.dom.bounds());\n  if (dest && cur.started && cur.orig !== dest) {\n    if (cur.newPiece) board.dropNewPiece(s, cur.orig, dest, cur.force);\n    else {\n      s.stats.ctrlKey = e.ctrlKey;\n      if (board.userMove(s, cur.orig, dest)) s.stats.dragged = true;\n    }\n  } else if (cur.newPiece) {\n    s.pieces.delete(cur.orig);\n  } else if (s.draggable.deleteOnDropOff && !dest) {\n    s.pieces.delete(cur.orig);\n    board.callUserFunction(s.events.change);\n  }\n  if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest)) board.unselect(s);\n  else if (!s.selectable.enabled) board.unselect(s);\n\n  removeDragElements(s);\n\n  s.draggable.current = undefined;\n  s.dom.redraw();\n}\n\nexport function cancel(s: State): void {\n  const cur = s.draggable.current;\n  if (cur) {\n    if (cur.newPiece) s.pieces.delete(cur.orig);\n    s.draggable.current = undefined;\n    board.unselect(s);\n    removeDragElements(s);\n    s.dom.redraw();\n  }\n}\n\nfunction removeDragElements(s: State): void {\n  const e = s.dom.elements;\n  if (e.ghost) util.setVisible(e.ghost, false);\n}\n\nfunction pieceElementByKey(s: State, key: cg.Key): cg.PieceNode | undefined {\n  let el = s.dom.elements.board.firstChild;\n  while (el) {\n    if ((el as cg.KeyedNode).cgKey === key && (el as cg.KeyedNode).tagName === 'PIECE') return el as cg.PieceNode;\n    el = el.nextSibling;\n  }\n  return;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}