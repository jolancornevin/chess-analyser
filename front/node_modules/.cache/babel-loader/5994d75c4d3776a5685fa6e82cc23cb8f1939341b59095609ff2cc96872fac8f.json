{"ast":null,"code":"import { pos2key, key2pos, opposite, distanceSq, allPos, computeSquareCenter } from './util.js';\nimport { premove, queen, knight } from './premove.js';\nexport function callUserFunction(f, ...args) {\n  if (f) setTimeout(() => f(...args), 1);\n}\nexport function toggleOrientation(state) {\n  state.orientation = opposite(state.orientation);\n  state.animation.current = state.draggable.current = state.selected = undefined;\n}\nexport function reset(state) {\n  state.lastMove = undefined;\n  unselect(state);\n  unsetPremove(state);\n  unsetPredrop(state);\n}\nexport function setPieces(state, pieces) {\n  for (const [key, piece] of pieces) {\n    if (piece) state.pieces.set(key, piece);else state.pieces.delete(key);\n  }\n}\nexport function setCheck(state, color) {\n  state.check = undefined;\n  if (color === true) color = state.turnColor;\n  if (color) for (const [k, p] of state.pieces) {\n    if (p.role === 'king' && p.color === color) {\n      state.check = k;\n    }\n  }\n}\nfunction setPremove(state, orig, dest, meta) {\n  unsetPredrop(state);\n  state.premovable.current = [orig, dest];\n  callUserFunction(state.premovable.events.set, orig, dest, meta);\n}\nexport function unsetPremove(state) {\n  if (state.premovable.current) {\n    state.premovable.current = undefined;\n    callUserFunction(state.premovable.events.unset);\n  }\n}\nfunction setPredrop(state, role, key) {\n  unsetPremove(state);\n  state.predroppable.current = {\n    role,\n    key\n  };\n  callUserFunction(state.predroppable.events.set, role, key);\n}\nexport function unsetPredrop(state) {\n  const pd = state.predroppable;\n  if (pd.current) {\n    pd.current = undefined;\n    callUserFunction(pd.events.unset);\n  }\n}\nfunction tryAutoCastle(state, orig, dest) {\n  if (!state.autoCastle) return false;\n  const king = state.pieces.get(orig);\n  if (!king || king.role !== 'king') return false;\n  const origPos = key2pos(orig);\n  const destPos = key2pos(dest);\n  if (origPos[1] !== 0 && origPos[1] !== 7 || origPos[1] !== destPos[1]) return false;\n  if (origPos[0] === 4 && !state.pieces.has(dest)) {\n    if (destPos[0] === 6) dest = pos2key([7, destPos[1]]);else if (destPos[0] === 2) dest = pos2key([0, destPos[1]]);\n  }\n  const rook = state.pieces.get(dest);\n  if (!rook || rook.color !== king.color || rook.role !== 'rook') return false;\n  state.pieces.delete(orig);\n  state.pieces.delete(dest);\n  if (origPos[0] < destPos[0]) {\n    state.pieces.set(pos2key([6, destPos[1]]), king);\n    state.pieces.set(pos2key([5, destPos[1]]), rook);\n  } else {\n    state.pieces.set(pos2key([2, destPos[1]]), king);\n    state.pieces.set(pos2key([3, destPos[1]]), rook);\n  }\n  return true;\n}\nexport function baseMove(state, orig, dest) {\n  const origPiece = state.pieces.get(orig),\n    destPiece = state.pieces.get(dest);\n  if (orig === dest || !origPiece) return false;\n  const captured = destPiece && destPiece.color !== origPiece.color ? destPiece : undefined;\n  if (dest === state.selected) unselect(state);\n  callUserFunction(state.events.move, orig, dest, captured);\n  if (!tryAutoCastle(state, orig, dest)) {\n    state.pieces.set(dest, origPiece);\n    state.pieces.delete(orig);\n  }\n  state.lastMove = [orig, dest];\n  state.check = undefined;\n  callUserFunction(state.events.change);\n  return captured || true;\n}\nexport function baseNewPiece(state, piece, key, force) {\n  if (state.pieces.has(key)) {\n    if (force) state.pieces.delete(key);else return false;\n  }\n  callUserFunction(state.events.dropNewPiece, piece, key);\n  state.pieces.set(key, piece);\n  state.lastMove = [key];\n  state.check = undefined;\n  callUserFunction(state.events.change);\n  state.movable.dests = undefined;\n  state.turnColor = opposite(state.turnColor);\n  return true;\n}\nfunction baseUserMove(state, orig, dest) {\n  const result = baseMove(state, orig, dest);\n  if (result) {\n    state.movable.dests = undefined;\n    state.turnColor = opposite(state.turnColor);\n    state.animation.current = undefined;\n  }\n  return result;\n}\nexport function userMove(state, orig, dest) {\n  if (canMove(state, orig, dest)) {\n    const result = baseUserMove(state, orig, dest);\n    if (result) {\n      const holdTime = state.hold.stop();\n      unselect(state);\n      const metadata = {\n        premove: false,\n        ctrlKey: state.stats.ctrlKey,\n        holdTime\n      };\n      if (result !== true) metadata.captured = result;\n      callUserFunction(state.movable.events.after, orig, dest, metadata);\n      return true;\n    }\n  } else if (canPremove(state, orig, dest)) {\n    setPremove(state, orig, dest, {\n      ctrlKey: state.stats.ctrlKey\n    });\n    unselect(state);\n    return true;\n  }\n  unselect(state);\n  return false;\n}\nexport function dropNewPiece(state, orig, dest, force) {\n  const piece = state.pieces.get(orig);\n  if (piece && (canDrop(state, orig, dest) || force)) {\n    state.pieces.delete(orig);\n    baseNewPiece(state, piece, dest, force);\n    callUserFunction(state.movable.events.afterNewPiece, piece.role, dest, {\n      premove: false,\n      predrop: false\n    });\n  } else if (piece && canPredrop(state, orig, dest)) {\n    setPredrop(state, piece.role, dest);\n  } else {\n    unsetPremove(state);\n    unsetPredrop(state);\n  }\n  state.pieces.delete(orig);\n  unselect(state);\n}\nexport function selectSquare(state, key, force) {\n  callUserFunction(state.events.select, key);\n  if (state.selected) {\n    if (state.selected === key && !state.draggable.enabled) {\n      unselect(state);\n      state.hold.cancel();\n      return;\n    } else if ((state.selectable.enabled || force) && state.selected !== key) {\n      if (userMove(state, state.selected, key)) {\n        state.stats.dragged = false;\n        return;\n      }\n    }\n  }\n  if ((state.selectable.enabled || state.draggable.enabled) && (isMovable(state, key) || isPremovable(state, key))) {\n    setSelected(state, key);\n    state.hold.start();\n  }\n}\nexport function setSelected(state, key) {\n  state.selected = key;\n  if (isPremovable(state, key)) {\n    state.premovable.dests = premove(state.pieces, key, state.premovable.castle);\n  } else state.premovable.dests = undefined;\n}\nexport function unselect(state) {\n  state.selected = undefined;\n  state.premovable.dests = undefined;\n  state.hold.cancel();\n}\nfunction isMovable(state, orig) {\n  const piece = state.pieces.get(orig);\n  return !!piece && (state.movable.color === 'both' || state.movable.color === piece.color && state.turnColor === piece.color);\n}\nexport const canMove = (state, orig, dest) => {\n  var _a, _b;\n  return orig !== dest && isMovable(state, orig) && (state.movable.free || !!((_b = (_a = state.movable.dests) === null || _a === void 0 ? void 0 : _a.get(orig)) === null || _b === void 0 ? void 0 : _b.includes(dest)));\n};\nfunction canDrop(state, orig, dest) {\n  const piece = state.pieces.get(orig);\n  return !!piece && (orig === dest || !state.pieces.has(dest)) && (state.movable.color === 'both' || state.movable.color === piece.color && state.turnColor === piece.color);\n}\nfunction isPremovable(state, orig) {\n  const piece = state.pieces.get(orig);\n  return !!piece && state.premovable.enabled && state.movable.color === piece.color && state.turnColor !== piece.color;\n}\nconst canPremove = (state, orig, dest) => orig !== dest && isPremovable(state, orig) && premove(state.pieces, orig, state.premovable.castle).includes(dest);\nfunction canPredrop(state, orig, dest) {\n  const piece = state.pieces.get(orig);\n  const destPiece = state.pieces.get(dest);\n  return !!piece && (!destPiece || destPiece.color !== state.movable.color) && state.predroppable.enabled && (piece.role !== 'pawn' || dest[1] !== '1' && dest[1] !== '8') && state.movable.color === piece.color && state.turnColor !== piece.color;\n}\nexport function isDraggable(state, orig) {\n  const piece = state.pieces.get(orig);\n  return !!piece && state.draggable.enabled && (state.movable.color === 'both' || state.movable.color === piece.color && (state.turnColor === piece.color || state.premovable.enabled));\n}\nexport function playPremove(state) {\n  const move = state.premovable.current;\n  if (!move) return false;\n  const orig = move[0],\n    dest = move[1];\n  let success = false;\n  if (canMove(state, orig, dest)) {\n    const result = baseUserMove(state, orig, dest);\n    if (result) {\n      const metadata = {\n        premove: true\n      };\n      if (result !== true) metadata.captured = result;\n      callUserFunction(state.movable.events.after, orig, dest, metadata);\n      success = true;\n    }\n  }\n  unsetPremove(state);\n  return success;\n}\nexport function playPredrop(state, validate) {\n  const drop = state.predroppable.current;\n  let success = false;\n  if (!drop) return false;\n  if (validate(drop)) {\n    const piece = {\n      role: drop.role,\n      color: state.movable.color\n    };\n    if (baseNewPiece(state, piece, drop.key)) {\n      callUserFunction(state.movable.events.afterNewPiece, drop.role, drop.key, {\n        premove: false,\n        predrop: true\n      });\n      success = true;\n    }\n  }\n  unsetPredrop(state);\n  return success;\n}\nexport function cancelMove(state) {\n  unsetPremove(state);\n  unsetPredrop(state);\n  unselect(state);\n}\nexport function stop(state) {\n  state.movable.color = state.movable.dests = state.animation.current = undefined;\n  cancelMove(state);\n}\nexport function getKeyAtDomPos(pos, asWhite, bounds) {\n  let file = Math.floor(8 * (pos[0] - bounds.left) / bounds.width);\n  if (!asWhite) file = 7 - file;\n  let rank = 7 - Math.floor(8 * (pos[1] - bounds.top) / bounds.height);\n  if (!asWhite) rank = 7 - rank;\n  return file >= 0 && file < 8 && rank >= 0 && rank < 8 ? pos2key([file, rank]) : undefined;\n}\nexport function getSnappedKeyAtDomPos(orig, pos, asWhite, bounds) {\n  const origPos = key2pos(orig);\n  const validSnapPos = allPos.filter(pos2 => queen(origPos[0], origPos[1], pos2[0], pos2[1]) || knight(origPos[0], origPos[1], pos2[0], pos2[1]));\n  const validSnapCenters = validSnapPos.map(pos2 => computeSquareCenter(pos2key(pos2), asWhite, bounds));\n  const validSnapDistances = validSnapCenters.map(pos2 => distanceSq(pos, pos2));\n  const [, closestSnapIndex] = validSnapDistances.reduce((a, b, index) => a[0] < b ? a : [b, index], [validSnapDistances[0], 0]);\n  return pos2key(validSnapPos[closestSnapIndex]);\n}\nexport const whitePov = s => s.orientation === 'white';","map":{"version":3,"names":["pos2key","key2pos","opposite","distanceSq","allPos","computeSquareCenter","premove","queen","knight","callUserFunction","f","args","setTimeout","toggleOrientation","state","orientation","animation","current","draggable","selected","undefined","reset","lastMove","unselect","unsetPremove","unsetPredrop","setPieces","pieces","key","piece","set","delete","setCheck","color","check","turnColor","k","p","role","setPremove","orig","dest","meta","premovable","events","unset","setPredrop","predroppable","pd","tryAutoCastle","autoCastle","king","get","origPos","destPos","has","rook","baseMove","origPiece","destPiece","captured","move","change","baseNewPiece","force","dropNewPiece","movable","dests","baseUserMove","result","userMove","canMove","holdTime","hold","stop","metadata","ctrlKey","stats","after","canPremove","canDrop","afterNewPiece","predrop","canPredrop","selectSquare","select","enabled","cancel","selectable","dragged","isMovable","isPremovable","setSelected","start","castle","_a","_b","free","includes","isDraggable","playPremove","success","playPredrop","validate","drop","cancelMove","getKeyAtDomPos","pos","asWhite","bounds","file","Math","floor","left","width","rank","top","height","getSnappedKeyAtDomPos","validSnapPos","filter","pos2","validSnapCenters","map","validSnapDistances","closestSnapIndex","reduce","a","b","index","whitePov","s"],"sources":["/Users/jcornevin/Dev/Perso/chess-analyser/node_modules/chessground/src/board.ts"],"sourcesContent":["import { HeadlessState } from './state.js';\nimport { pos2key, key2pos, opposite, distanceSq, allPos, computeSquareCenter } from './util.js';\nimport { premove, queen, knight } from './premove.js';\nimport * as cg from './types.js';\n\nexport function callUserFunction<T extends (...args: any[]) => void>(f: T | undefined, ...args: Parameters<T>): void {\n  if (f) setTimeout(() => f(...args), 1);\n}\n\nexport function toggleOrientation(state: HeadlessState): void {\n  state.orientation = opposite(state.orientation);\n  state.animation.current = state.draggable.current = state.selected = undefined;\n}\n\nexport function reset(state: HeadlessState): void {\n  state.lastMove = undefined;\n  unselect(state);\n  unsetPremove(state);\n  unsetPredrop(state);\n}\n\nexport function setPieces(state: HeadlessState, pieces: cg.PiecesDiff): void {\n  for (const [key, piece] of pieces) {\n    if (piece) state.pieces.set(key, piece);\n    else state.pieces.delete(key);\n  }\n}\n\nexport function setCheck(state: HeadlessState, color: cg.Color | boolean): void {\n  state.check = undefined;\n  if (color === true) color = state.turnColor;\n  if (color)\n    for (const [k, p] of state.pieces) {\n      if (p.role === 'king' && p.color === color) {\n        state.check = k;\n      }\n    }\n}\n\nfunction setPremove(state: HeadlessState, orig: cg.Key, dest: cg.Key, meta: cg.SetPremoveMetadata): void {\n  unsetPredrop(state);\n  state.premovable.current = [orig, dest];\n  callUserFunction(state.premovable.events.set, orig, dest, meta);\n}\n\nexport function unsetPremove(state: HeadlessState): void {\n  if (state.premovable.current) {\n    state.premovable.current = undefined;\n    callUserFunction(state.premovable.events.unset);\n  }\n}\n\nfunction setPredrop(state: HeadlessState, role: cg.Role, key: cg.Key): void {\n  unsetPremove(state);\n  state.predroppable.current = { role, key };\n  callUserFunction(state.predroppable.events.set, role, key);\n}\n\nexport function unsetPredrop(state: HeadlessState): void {\n  const pd = state.predroppable;\n  if (pd.current) {\n    pd.current = undefined;\n    callUserFunction(pd.events.unset);\n  }\n}\n\nfunction tryAutoCastle(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  if (!state.autoCastle) return false;\n\n  const king = state.pieces.get(orig);\n  if (!king || king.role !== 'king') return false;\n\n  const origPos = key2pos(orig);\n  const destPos = key2pos(dest);\n  if ((origPos[1] !== 0 && origPos[1] !== 7) || origPos[1] !== destPos[1]) return false;\n  if (origPos[0] === 4 && !state.pieces.has(dest)) {\n    if (destPos[0] === 6) dest = pos2key([7, destPos[1]]);\n    else if (destPos[0] === 2) dest = pos2key([0, destPos[1]]);\n  }\n  const rook = state.pieces.get(dest);\n  if (!rook || rook.color !== king.color || rook.role !== 'rook') return false;\n\n  state.pieces.delete(orig);\n  state.pieces.delete(dest);\n\n  if (origPos[0] < destPos[0]) {\n    state.pieces.set(pos2key([6, destPos[1]]), king);\n    state.pieces.set(pos2key([5, destPos[1]]), rook);\n  } else {\n    state.pieces.set(pos2key([2, destPos[1]]), king);\n    state.pieces.set(pos2key([3, destPos[1]]), rook);\n  }\n  return true;\n}\n\nexport function baseMove(state: HeadlessState, orig: cg.Key, dest: cg.Key): cg.Piece | boolean {\n  const origPiece = state.pieces.get(orig),\n    destPiece = state.pieces.get(dest);\n  if (orig === dest || !origPiece) return false;\n  const captured = destPiece && destPiece.color !== origPiece.color ? destPiece : undefined;\n  if (dest === state.selected) unselect(state);\n  callUserFunction(state.events.move, orig, dest, captured);\n  if (!tryAutoCastle(state, orig, dest)) {\n    state.pieces.set(dest, origPiece);\n    state.pieces.delete(orig);\n  }\n  state.lastMove = [orig, dest];\n  state.check = undefined;\n  callUserFunction(state.events.change);\n  return captured || true;\n}\n\nexport function baseNewPiece(state: HeadlessState, piece: cg.Piece, key: cg.Key, force?: boolean): boolean {\n  if (state.pieces.has(key)) {\n    if (force) state.pieces.delete(key);\n    else return false;\n  }\n  callUserFunction(state.events.dropNewPiece, piece, key);\n  state.pieces.set(key, piece);\n  state.lastMove = [key];\n  state.check = undefined;\n  callUserFunction(state.events.change);\n  state.movable.dests = undefined;\n  state.turnColor = opposite(state.turnColor);\n  return true;\n}\n\nfunction baseUserMove(state: HeadlessState, orig: cg.Key, dest: cg.Key): cg.Piece | boolean {\n  const result = baseMove(state, orig, dest);\n  if (result) {\n    state.movable.dests = undefined;\n    state.turnColor = opposite(state.turnColor);\n    state.animation.current = undefined;\n  }\n  return result;\n}\n\nexport function userMove(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  if (canMove(state, orig, dest)) {\n    const result = baseUserMove(state, orig, dest);\n    if (result) {\n      const holdTime = state.hold.stop();\n      unselect(state);\n      const metadata: cg.MoveMetadata = {\n        premove: false,\n        ctrlKey: state.stats.ctrlKey,\n        holdTime,\n      };\n      if (result !== true) metadata.captured = result;\n      callUserFunction(state.movable.events.after, orig, dest, metadata);\n      return true;\n    }\n  } else if (canPremove(state, orig, dest)) {\n    setPremove(state, orig, dest, {\n      ctrlKey: state.stats.ctrlKey,\n    });\n    unselect(state);\n    return true;\n  }\n  unselect(state);\n  return false;\n}\n\nexport function dropNewPiece(state: HeadlessState, orig: cg.Key, dest: cg.Key, force?: boolean): void {\n  const piece = state.pieces.get(orig);\n  if (piece && (canDrop(state, orig, dest) || force)) {\n    state.pieces.delete(orig);\n    baseNewPiece(state, piece, dest, force);\n    callUserFunction(state.movable.events.afterNewPiece, piece.role, dest, {\n      premove: false,\n      predrop: false,\n    });\n  } else if (piece && canPredrop(state, orig, dest)) {\n    setPredrop(state, piece.role, dest);\n  } else {\n    unsetPremove(state);\n    unsetPredrop(state);\n  }\n  state.pieces.delete(orig);\n  unselect(state);\n}\n\nexport function selectSquare(state: HeadlessState, key: cg.Key, force?: boolean): void {\n  callUserFunction(state.events.select, key);\n  if (state.selected) {\n    if (state.selected === key && !state.draggable.enabled) {\n      unselect(state);\n      state.hold.cancel();\n      return;\n    } else if ((state.selectable.enabled || force) && state.selected !== key) {\n      if (userMove(state, state.selected, key)) {\n        state.stats.dragged = false;\n        return;\n      }\n    }\n  }\n  if ((state.selectable.enabled || state.draggable.enabled) && (isMovable(state, key) || isPremovable(state, key))) {\n    setSelected(state, key);\n    state.hold.start();\n  }\n}\n\nexport function setSelected(state: HeadlessState, key: cg.Key): void {\n  state.selected = key;\n  if (isPremovable(state, key)) {\n    state.premovable.dests = premove(state.pieces, key, state.premovable.castle);\n  } else state.premovable.dests = undefined;\n}\n\nexport function unselect(state: HeadlessState): void {\n  state.selected = undefined;\n  state.premovable.dests = undefined;\n  state.hold.cancel();\n}\n\nfunction isMovable(state: HeadlessState, orig: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return (\n    !!piece &&\n    (state.movable.color === 'both' || (state.movable.color === piece.color && state.turnColor === piece.color))\n  );\n}\n\nexport const canMove = (state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean =>\n  orig !== dest && isMovable(state, orig) && (state.movable.free || !!state.movable.dests?.get(orig)?.includes(dest));\n\nfunction canDrop(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return (\n    !!piece &&\n    (orig === dest || !state.pieces.has(dest)) &&\n    (state.movable.color === 'both' || (state.movable.color === piece.color && state.turnColor === piece.color))\n  );\n}\n\nfunction isPremovable(state: HeadlessState, orig: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return !!piece && state.premovable.enabled && state.movable.color === piece.color && state.turnColor !== piece.color;\n}\n\nconst canPremove = (state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean =>\n  orig !== dest && isPremovable(state, orig) && premove(state.pieces, orig, state.premovable.castle).includes(dest);\n\nfunction canPredrop(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  const destPiece = state.pieces.get(dest);\n  return (\n    !!piece &&\n    (!destPiece || destPiece.color !== state.movable.color) &&\n    state.predroppable.enabled &&\n    (piece.role !== 'pawn' || (dest[1] !== '1' && dest[1] !== '8')) &&\n    state.movable.color === piece.color &&\n    state.turnColor !== piece.color\n  );\n}\n\nexport function isDraggable(state: HeadlessState, orig: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return (\n    !!piece &&\n    state.draggable.enabled &&\n    (state.movable.color === 'both' ||\n      (state.movable.color === piece.color && (state.turnColor === piece.color || state.premovable.enabled)))\n  );\n}\n\nexport function playPremove(state: HeadlessState): boolean {\n  const move = state.premovable.current;\n  if (!move) return false;\n  const orig = move[0],\n    dest = move[1];\n  let success = false;\n  if (canMove(state, orig, dest)) {\n    const result = baseUserMove(state, orig, dest);\n    if (result) {\n      const metadata: cg.MoveMetadata = { premove: true };\n      if (result !== true) metadata.captured = result;\n      callUserFunction(state.movable.events.after, orig, dest, metadata);\n      success = true;\n    }\n  }\n  unsetPremove(state);\n  return success;\n}\n\nexport function playPredrop(state: HeadlessState, validate: (drop: cg.Drop) => boolean): boolean {\n  const drop = state.predroppable.current;\n  let success = false;\n  if (!drop) return false;\n  if (validate(drop)) {\n    const piece = {\n      role: drop.role,\n      color: state.movable.color,\n    } as cg.Piece;\n    if (baseNewPiece(state, piece, drop.key)) {\n      callUserFunction(state.movable.events.afterNewPiece, drop.role, drop.key, {\n        premove: false,\n        predrop: true,\n      });\n      success = true;\n    }\n  }\n  unsetPredrop(state);\n  return success;\n}\n\nexport function cancelMove(state: HeadlessState): void {\n  unsetPremove(state);\n  unsetPredrop(state);\n  unselect(state);\n}\n\nexport function stop(state: HeadlessState): void {\n  state.movable.color = state.movable.dests = state.animation.current = undefined;\n  cancelMove(state);\n}\n\nexport function getKeyAtDomPos(pos: cg.NumberPair, asWhite: boolean, bounds: ClientRect): cg.Key | undefined {\n  let file = Math.floor((8 * (pos[0] - bounds.left)) / bounds.width);\n  if (!asWhite) file = 7 - file;\n  let rank = 7 - Math.floor((8 * (pos[1] - bounds.top)) / bounds.height);\n  if (!asWhite) rank = 7 - rank;\n  return file >= 0 && file < 8 && rank >= 0 && rank < 8 ? pos2key([file, rank]) : undefined;\n}\n\nexport function getSnappedKeyAtDomPos(\n  orig: cg.Key,\n  pos: cg.NumberPair,\n  asWhite: boolean,\n  bounds: ClientRect\n): cg.Key | undefined {\n  const origPos = key2pos(orig);\n  const validSnapPos = allPos.filter(\n    pos2 => queen(origPos[0], origPos[1], pos2[0], pos2[1]) || knight(origPos[0], origPos[1], pos2[0], pos2[1])\n  );\n  const validSnapCenters = validSnapPos.map(pos2 => computeSquareCenter(pos2key(pos2), asWhite, bounds));\n  const validSnapDistances = validSnapCenters.map(pos2 => distanceSq(pos, pos2));\n  const [, closestSnapIndex] = validSnapDistances.reduce(\n    (a, b, index) => (a[0] < b ? a : [b, index]),\n    [validSnapDistances[0], 0]\n  );\n  return pos2key(validSnapPos[closestSnapIndex]);\n}\n\nexport const whitePov = (s: HeadlessState): boolean => s.orientation === 'white';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}