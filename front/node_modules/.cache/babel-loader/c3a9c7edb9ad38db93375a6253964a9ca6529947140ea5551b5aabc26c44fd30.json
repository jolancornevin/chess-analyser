{"ast":null,"code":"import { engineEval } from './right-menu/engine';\nexport function NewLine(rawScore, scoreType, line) {\n  const isMate = scoreType === \"mate\";\n  const score = isMate ? rawScore : rawScore / 100;\n  return {\n    score: `${isMate ? \"M\" : \"\"}${score}`,\n    // in pawns\n    rawScore: rawScore,\n    // in centipawns\n    scoreType: scoreType,\n    line: line\n  };\n}\n_c = NewLine;\nexport function NewMove(value, moveNumber) {\n  return {\n    to: value.to,\n    fen: value.after,\n    number: moveNumber,\n    cmove: value\n  };\n}\n_c2 = NewMove;\nexport async function ComputeMoveScore(move) {\n  return new Promise(async (resolve, reject) => {\n    await engineEval(move.cmove.before, 3).then(async linesBefore => {\n      await engineEval(move.cmove.after, 3).then(linesAfter => {\n        let accuracy = 0;\n        let scoreDiff = 0;\n        console.log(`>>>> got scores for move ${move.to} with ${move.cmove.before} and ${move.cmove.after}`);\n        if (linesBefore.length > 0 && linesAfter.length > 0) {\n          const bestLineBefore = linesBefore[0];\n\n          // taking the last one because we want the best line for our opponent\n          const bestLineAfter = linesAfter[0];\n          // Addition to take the perspective of the player playing, so we reverse the score.\n          // if we're white, the line after give a score for black, which will be negative if good for us.\n          bestLineAfter.rawScore *= -1;\n          const winPercentBefore = (2 / (1 + Math.exp(-0.00368208 * bestLineBefore.rawScore)) - 1) * 100;\n          const winPercentAfter = (2 / (1 + Math.exp(-0.00368208 * bestLineAfter.rawScore)) - 1) * 100;\n          if (winPercentAfter > winPercentBefore) {\n            accuracy = 100;\n          } else {\n            accuracy = Math.round(103.1668100711649 * Math.exp(-0.04354415386753951 * (winPercentBefore - winPercentAfter)) - 3.166924740191411);\n          }\n          scoreDiff = bestLineBefore.rawScore - bestLineAfter.rawScore;\n          console.log({\n            moveNumber: move.number,\n            linesBefore,\n            bestLineBefore,\n            winPercentBefore,\n            linesAfter,\n            bestLineAfter,\n            winPercentAfter,\n            accuracy,\n            scoreDiff\n          });\n          // if (scoreDiff < 0) {\n          // }\n\n          // TODO think more about the evals I want\n          // I need to compare the score AFTER the move VS the best line BEFORE the move (+all other metrics)\n          // If I want a graph, then I want the best score BEFORE each move.\n\n          const newMove = {\n            ...move,\n            scoreDiff: scoreDiff,\n            // (linesBefore.length > 0 ? linesBefore[0].score : \"-\")\n            accuracy: accuracy,\n            scoreBefore: bestLineBefore.rawScore,\n            scoreAfter: bestLineAfter.rawScore\n          };\n          resolve(newMove);\n        } else {\n          resolve(move);\n        }\n      });\n    });\n  });\n}\n_c3 = ComputeMoveScore;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"NewLine\");\n$RefreshReg$(_c2, \"NewMove\");\n$RefreshReg$(_c3, \"ComputeMoveScore\");","map":{"version":3,"names":["engineEval","NewLine","rawScore","scoreType","line","isMate","score","_c","NewMove","value","moveNumber","to","fen","after","number","cmove","_c2","ComputeMoveScore","move","Promise","resolve","reject","before","then","linesBefore","linesAfter","accuracy","scoreDiff","console","log","length","bestLineBefore","bestLineAfter","winPercentBefore","Math","exp","winPercentAfter","round","newMove","scoreBefore","scoreAfter","_c3","$RefreshReg$"],"sources":["/Users/jcornevin/Dev/Perso/chess-analyser/src/components/types.ts"],"sourcesContent":["\nimport { Move as cMove } from 'chess.js';\nimport { engineEval } from './right-menu/engine';\n\n\nexport interface Line {\n    line: string;\n\n    scoreType: string;\n\n    rawScore: number;\n    score: string;\n}\n\nexport function NewLine(rawScore, scoreType, line): Line {\n    const isMate = scoreType === \"mate\";\n    const score = isMate ? rawScore : rawScore / 100;\n    \n    return {\n        score: `${isMate ? \"M\" : \"\"}${score}`, // in pawns\n        rawScore: rawScore, // in centipawns\n        scoreType:scoreType,\n        line: line,\n    } \n}\n\n\nexport interface Move {\n    number: number;\n    to: string; // move (d4)\n    fen: string;\n    \n    cmove?: cMove;\n    scoreDiff?: number;\n    accuracy?: number;\n\n    scoreBefore?: number;\n    scoreAfter?: number;\n}\nexport function NewMove(value: cMove, moveNumber): Move {\n    return {\n        to: value.to,\n        fen: value.after,\n        number: moveNumber,\n        cmove: value,\n    }\n}\n\nexport async function ComputeMoveScore(move: Move): Promise<Move> {   \n    return new Promise(async (resolve, reject) => {\n        await engineEval(move.cmove.before, 3).then(async (linesBefore) => {\n            await engineEval(move.cmove.after, 3).then((linesAfter) => {\n                let accuracy = 0;\n                let scoreDiff = 0;\n\n                console.log(`>>>> got scores for move ${move.to} with ${move.cmove.before} and ${move.cmove.after}`);\n\n                if (linesBefore.length > 0 && linesAfter.length > 0) {\n                    const bestLineBefore = linesBefore[0];\n\n                    // taking the last one because we want the best line for our opponent\n                    const bestLineAfter = linesAfter[0];\n                    // Addition to take the perspective of the player playing, so we reverse the score.\n                    // if we're white, the line after give a score for black, which will be negative if good for us.\n                    bestLineAfter.rawScore *= -1;\n                    \n                    const winPercentBefore = (2 / (1 + Math.exp(-0.00368208 * bestLineBefore.rawScore)) - 1) * 100;\n                    const winPercentAfter = (2 / (1 + Math.exp(-0.00368208 * bestLineAfter.rawScore)) - 1) * 100;\n\n                    if (winPercentAfter > winPercentBefore) {\n                        accuracy = 100\n                    } else {\n                        accuracy = Math.round(103.1668100711649 * Math.exp(-0.04354415386753951 * (winPercentBefore - winPercentAfter)) -3.166924740191411);\n                    }\n\n                    scoreDiff = bestLineBefore.rawScore - bestLineAfter.rawScore;\n                    \n                    console.log({ moveNumber: move.number, linesBefore, bestLineBefore, winPercentBefore, linesAfter, bestLineAfter, winPercentAfter, accuracy, scoreDiff });\n                    // if (scoreDiff < 0) {\n                    // }\n\n                    // TODO think more about the evals I want\n                    // I need to compare the score AFTER the move VS the best line BEFORE the move (+all other metrics)\n                    // If I want a graph, then I want the best score BEFORE each move.\n\n                    const newMove = {\n                        ...move,\n\n                        scoreDiff: scoreDiff, // (linesBefore.length > 0 ? linesBefore[0].score : \"-\")\n                        accuracy: accuracy,\n        \n                        scoreBefore: bestLineBefore.rawScore,\n                        scoreAfter: bestLineAfter.rawScore,\n                    };\n\n                    resolve(newMove);\n                } else {\n                    resolve(move);\n                }\n            });         \n        }); \n    });\n    \n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}