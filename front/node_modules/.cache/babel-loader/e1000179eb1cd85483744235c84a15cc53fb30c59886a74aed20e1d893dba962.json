{"ast":null,"code":"import { engineEval } from './right-menu/engine';\nexport function NewLine(rawScore, scoreType, line) {\n  const isMate = scoreType === \"mate\";\n  const score = isMate ? rawScore : rawScore / 100;\n  return {\n    score: `${isMate ? \"M\" : \"\"}${score}`,\n    // in pawns\n    rawScore: rawScore,\n    // in centipawns\n    scoreType: scoreType,\n    line: line\n  };\n}\n_c = NewLine;\nexport async function NewMove(value, moveNumber) {\n  await engineEval(value.before, 3).then(async linesBefore => {\n    await engineEval(value.after, 3).then(linesAfter => {\n      let accuracy = 0;\n      let evaluation = 0;\n      if (linesBefore.length > 0 && linesAfter.length > 0) {\n        const bestLineBefore = linesBefore[0];\n        const bestLineAfter = linesAfter[0];\n        const winPercentBefore = 2 / (1 + Math.exp(-0.00368208 * bestLineBefore.rawScore)) - 1;\n        const winPercentAfter = 2 / (1 + Math.exp(-0.00368208 * bestLineAfter.rawScore)) - 1;\n        if (winPercentAfter > winPercentBefore) {\n          accuracy = 100;\n        } else {\n          accuracy = Math.round(103.1668100711649 * Math.exp(-0.04354415386753951 * (winPercentBefore - winPercentAfter)) - 3.166924740191411);\n        }\n        console.log({\n          moveNumber,\n          linesBefore,\n          bestLineBefore,\n          winPercentBefore,\n          linesAfter,\n          bestLineAfter,\n          winPercentAfter,\n          accuracy\n        });\n        evaluation = bestLineBefore.rawScore - bestLineAfter.rawScore;\n        // if (evaluation < 0) {\n        // }\n      }\n\n      // TODO think more about the evals I want\n      // I need to compare the score AFTER the move VS the best line BEFORE the move (+all other metrics)\n      // If I want a graph, then I want the best score BEFORE each move. \n      return {\n        to: value.to,\n        fen: value.after,\n        number: moveNumber,\n        eval: `${evaluation}`,\n        // (linesBefore.length > 0 ? linesBefore[0].score : \"-\")\n        accuracy: accuracy\n      };\n    });\n  });\n  return {\n    to: value.to,\n    fen: value.after,\n    number: moveNumber,\n    eval: `${evaluation}`,\n    // (linesBefore.length > 0 ? linesBefore[0].score : \"-\")\n    accuracy: accuracy\n  };\n}\n_c2 = NewMove;\nvar _c, _c2;\n$RefreshReg$(_c, \"NewLine\");\n$RefreshReg$(_c2, \"NewMove\");","map":{"version":3,"names":["engineEval","NewLine","rawScore","scoreType","line","isMate","score","_c","NewMove","value","moveNumber","before","then","linesBefore","after","linesAfter","accuracy","evaluation","length","bestLineBefore","bestLineAfter","winPercentBefore","Math","exp","winPercentAfter","round","console","log","to","fen","number","eval","_c2","$RefreshReg$"],"sources":["/Users/jcornevin/Dev/Perso/chess-analyser/src/components/types.ts"],"sourcesContent":["\nimport { Move as cMove } from 'chess.js';\nimport { engineEval } from './right-menu/engine';\n\nexport function NewLine(rawScore, scoreType, line): Line {\n    const isMate = scoreType === \"mate\";\n    const score = isMate ? rawScore : rawScore / 100;\n    \n    return {\n        score: `${isMate ? \"M\" : \"\"}${score}`, // in pawns\n        rawScore: rawScore, // in centipawns\n        scoreType:scoreType,\n        line: line,\n    } \n}\nexport async function NewMove(value: cMove, moveNumber) {\n    await engineEval(value.before, 3).then(async (linesBefore) => {\n        await engineEval(value.after, 3).then((linesAfter) => {\n            let accuracy = 0;\n            let evaluation = 0;\n\n            if (linesBefore.length > 0 && linesAfter.length > 0) {\n                const bestLineBefore = linesBefore[0];\n                const bestLineAfter = linesAfter[0];\n                \n                const winPercentBefore = 2 / (1 + Math.exp(-0.00368208 * bestLineBefore.rawScore)) - 1;\n                const winPercentAfter = 2 / (1 + Math.exp(-0.00368208 * bestLineAfter.rawScore)) - 1;\n\n                if (winPercentAfter > winPercentBefore) {\n                    accuracy = 100\n                } else {\n                    accuracy = Math.round(103.1668100711649 * Math.exp(-0.04354415386753951 * (winPercentBefore - winPercentAfter)) -3.166924740191411);\n                }\n                console.log({moveNumber, linesBefore, bestLineBefore, winPercentBefore, linesAfter, bestLineAfter, winPercentAfter, accuracy})\n\n                evaluation = bestLineBefore.rawScore - bestLineAfter.rawScore;\n                // if (evaluation < 0) {\n                // }\n            }\n\n            // TODO think more about the evals I want\n            // I need to compare the score AFTER the move VS the best line BEFORE the move (+all other metrics)\n            // If I want a graph, then I want the best score BEFORE each move. \n            return {\n                to: value.to,\n                fen: value.after,\n                number: moveNumber,\n                eval: `${evaluation}`, // (linesBefore.length > 0 ? linesBefore[0].score : \"-\")\n                accuracy: accuracy,\n            }\n        });         \n    });            \n    \n    return {\n        to: value.to,\n        fen: value.after,\n        number: moveNumber,\n        eval: `${evaluation}`, // (linesBefore.length > 0 ? linesBefore[0].score : \"-\")\n        accuracy: accuracy,\n    }\n}\n\nexport interface Line {\n    line: string;\n\n    scoreType: string;\n\n    rawScore: number;\n    score: string;\n}\n\nexport interface Move {\n    number: number;\n\n    eval: string;\n    accuracy: number;\n\n    to: string;\n    fen: string;\n}\n"],"mappings":"AAEA,SAASA,UAAU,QAAQ,qBAAqB;AAEhD,OAAO,SAASC,OAAOA,CAACC,QAAQ,EAAEC,SAAS,EAAEC,IAAI,EAAQ;EACrD,MAAMC,MAAM,GAAGF,SAAS,KAAK,MAAM;EACnC,MAAMG,KAAK,GAAGD,MAAM,GAAGH,QAAQ,GAAGA,QAAQ,GAAG,GAAG;EAEhD,OAAO;IACHI,KAAK,EAAE,GAAGD,MAAM,GAAG,GAAG,GAAG,EAAE,GAAGC,KAAK,EAAE;IAAE;IACvCJ,QAAQ,EAAEA,QAAQ;IAAE;IACpBC,SAAS,EAACA,SAAS;IACnBC,IAAI,EAAEA;EACV,CAAC;AACL;AAACG,EAAA,GAVeN,OAAO;AAWvB,OAAO,eAAeO,OAAOA,CAACC,KAAY,EAAEC,UAAU,EAAE;EACpD,MAAMV,UAAU,CAACS,KAAK,CAACE,MAAM,EAAE,CAAC,CAAC,CAACC,IAAI,CAAC,MAAOC,WAAW,IAAK;IAC1D,MAAMb,UAAU,CAACS,KAAK,CAACK,KAAK,EAAE,CAAC,CAAC,CAACF,IAAI,CAAEG,UAAU,IAAK;MAClD,IAAIC,QAAQ,GAAG,CAAC;MAChB,IAAIC,UAAU,GAAG,CAAC;MAElB,IAAIJ,WAAW,CAACK,MAAM,GAAG,CAAC,IAAIH,UAAU,CAACG,MAAM,GAAG,CAAC,EAAE;QACjD,MAAMC,cAAc,GAAGN,WAAW,CAAC,CAAC,CAAC;QACrC,MAAMO,aAAa,GAAGL,UAAU,CAAC,CAAC,CAAC;QAEnC,MAAMM,gBAAgB,GAAG,CAAC,IAAI,CAAC,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,UAAU,GAAGJ,cAAc,CAACjB,QAAQ,CAAC,CAAC,GAAG,CAAC;QACtF,MAAMsB,eAAe,GAAG,CAAC,IAAI,CAAC,GAAGF,IAAI,CAACC,GAAG,CAAC,CAAC,UAAU,GAAGH,aAAa,CAAClB,QAAQ,CAAC,CAAC,GAAG,CAAC;QAEpF,IAAIsB,eAAe,GAAGH,gBAAgB,EAAE;UACpCL,QAAQ,GAAG,GAAG;QAClB,CAAC,MAAM;UACHA,QAAQ,GAAGM,IAAI,CAACG,KAAK,CAAC,iBAAiB,GAAGH,IAAI,CAACC,GAAG,CAAC,CAAC,mBAAmB,IAAIF,gBAAgB,GAAGG,eAAe,CAAC,CAAC,GAAE,iBAAiB,CAAC;QACvI;QACAE,OAAO,CAACC,GAAG,CAAC;UAACjB,UAAU;UAAEG,WAAW;UAAEM,cAAc;UAAEE,gBAAgB;UAAEN,UAAU;UAAEK,aAAa;UAAEI,eAAe;UAAER;QAAQ,CAAC,CAAC;QAE9HC,UAAU,GAAGE,cAAc,CAACjB,QAAQ,GAAGkB,aAAa,CAAClB,QAAQ;QAC7D;QACA;MACJ;;MAEA;MACA;MACA;MACA,OAAO;QACH0B,EAAE,EAAEnB,KAAK,CAACmB,EAAE;QACZC,GAAG,EAAEpB,KAAK,CAACK,KAAK;QAChBgB,MAAM,EAAEpB,UAAU;QAClBqB,IAAI,EAAE,GAAGd,UAAU,EAAE;QAAE;QACvBD,QAAQ,EAAEA;MACd,CAAC;IACL,CAAC,CAAC;EACN,CAAC,CAAC;EAEF,OAAO;IACHY,EAAE,EAAEnB,KAAK,CAACmB,EAAE;IACZC,GAAG,EAAEpB,KAAK,CAACK,KAAK;IAChBgB,MAAM,EAAEpB,UAAU;IAClBqB,IAAI,EAAE,GAAGd,UAAU,EAAE;IAAE;IACvBD,QAAQ,EAAEA;EACd,CAAC;AACL;AAACgB,GAAA,GA7CqBxB,OAAO;AAAA,IAAAD,EAAA,EAAAyB,GAAA;AAAAC,YAAA,CAAA1B,EAAA;AAAA0B,YAAA,CAAAD,GAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}